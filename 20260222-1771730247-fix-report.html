<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard å¯¦ç¾ä¿®å¾©å ±å‘Š</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
        }
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #007bff;
            color: white;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            color: #666;
            font-size: 0.9em;
        }
        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #007bff;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dashboard å¯¦ç¾ä¿®å¾©å ±å‘Š</h1>
<p><strong>ä¿®å¾©ç·¨è™Ÿ:</strong> FR-2026-0222-001<br />
<strong>ä»»å‹™ç·¨è™Ÿ:</strong> s101c<br />
<strong>ä¿®å¾©è€…:</strong> Developer Agent (subagent)<br />
<strong>ä¿®å¾©æ—¥æœŸ:</strong> 2026-02-22<br />
<strong>ä¿®å¾©ç‹€æ…‹:</strong> âœ… å®Œæˆ</p>
<hr />
<h2>ğŸ“‹ ä¿®å¾©æ¦‚è¿°</h2>
<p>æ ¹æ“š Architect å¯©æŸ¥å ±å‘Š (AR-2026-0222-001)ï¼Œå®Œæˆ s101c Dashboard å¯¦ç¾çš„æ‰€æœ‰é—œéµå•é¡Œä¿®å¾©å’Œä¸­å„ªå…ˆç´šæ”¹é€²ã€‚</p>
<hr />
<h2>ğŸ”§ Phase 1: é—œéµå•é¡Œä¿®å¾© (å¿…é ˆä¿®å¾©)</h2>
<h3>ä¿®å¾© 1.1: æ‹¼å¯«éŒ¯èª¤ä¿®æ­£</h3>
<p><strong>å•é¡Œä½ç½®:</strong> æ¸¬è©¦å ´æ™¯ B<br />
<strong>åŸå•é¡Œ:</strong> <code>HighCPUMockockDataFetcher</code><br />
<strong>ä¿®å¾©æ–¹æ¡ˆ:</strong> æ”¹ç‚º <code>HighCPUMockDataFetcher</code></p>
<pre class="codehilite"><code class="language-typescript">// âŒ ä¿®å¾©å‰
const dataFetcher = new HighCPUMockockDataFetcher();

// âœ… ä¿®å¾©å¾Œ
const dataFetcher = new HighCPUMockDataFetcher();
</code></pre>

<hr />
<h3>ä¿®å¾© 1.2: éŒ¯èª¤è™•ç†ç­–ç•¥å¯¦ç¾</h3>
<p><strong>å•é¡Œä½ç½®:</strong> DashboardService<br />
<strong>åŸå•é¡Œ:</strong> æœªå¯¦ç¾ s101b è¦å®šçš„ Retryã€Fallbackã€Degraded Mode ç­–ç•¥<br />
<strong>ä¿®å¾©æ–¹æ¡ˆ:</strong> å¯¦ç¾å®Œæ•´çš„éŒ¯èª¤è™•ç†ç­–ç•¥</p>
<pre class="codehilite"><code class="language-typescript">class DashboardService {
  private dataFetcher: DataFetcher;
  private cache: DashboardData | null = null;
  private lastCacheTime: Date | null = null;
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  constructor(dataFetcher: DataFetcher) {
    this.dataFetcher = dataFetcher;
  }

  async generateDashboard(): Promise&lt;DashboardData&gt; {
    try {
      const [metrics, alerts, status] = await Promise.all([
        this.fetchWithRetry(() =&gt; this.dataFetcher.fetchMetrics()),
        this.fetchWithRetry(() =&gt; this.dataFetcher.fetchAlerts()),
        this.fetchWithRetry(() =&gt; this.dataFetcher.fetchStatus())
      ]);

      const healthScore = this.calculateHealthScore(metrics);
      const filteredAlerts = this.filterAlerts(alerts);

      const dashboardData: DashboardData = {
        metrics,
        alerts: filteredAlerts,
        status,
        healthScore,
        generatedAt: new Date()
      };

      // æ›´æ–°ç·©å­˜
      this.cache = dashboardData;
      this.lastCacheTime = new Date();

      return dashboardData;

    } catch (error) {
      console.error('Data fetch failed, using fallback:', error.message);

      // Fallback: è¿”å›ç·©å­˜æ•¸æ“šæˆ–é™ç´šæ¨¡å¼
      if (this.cache &amp;&amp; this.lastCacheTime &amp;&amp; 
          (Date.now() - this.lastCacheTime.getTime()) &lt; this.CACHE_DURATION) {
        console.log('Using cached data');
        return {
          ...this.cache,
          generatedAt: new Date(),
          status: {
            ...this.cache.status,
            healthy: false,
            lastUpdate: new Date()
          }
        };
      }

      // Degraded Mode: è¿”å›æœ€å°å¯ç”¨æ•¸æ“š
      return this.getDegradedDashboard();
    }
  }

  /**
   * å¯¦ç¾é‡è©¦æ©Ÿåˆ¶ (3æ¬¡ï¼ŒæŒ‡æ•¸é€€é¿)
   */
  private async fetchWithRetry&lt;T&gt;(fetchFn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {
    let lastError: Error;

    for (let i = 0; i &lt; 3; i++) {
      try {
        return await fetchFn();
      } catch (error) {
        lastError = error;
        if (i &lt; 2) {
          const delay = Math.pow(2, i) * 1000; // æŒ‡æ•¸é€€é¿: 1s, 2s, 4s
          console.log(`Retry ${i + 1} after ${delay}ms`);
          await this.sleep(delay);
        }
      }
    }

    throw lastError;
  }

  /**
   * é™ç´šæ¨¡å¼ï¼šè¿”å›æœ€å°å¯ç”¨æ•¸æ“š
   */
  private getDegradedDashboard(): DashboardData {
    return {
      metrics: new Map(),
      alerts: [{
        id: 'degraded-mode-alert',
        level: 'error' as const,
        message: 'Data source unavailable - showing degraded mode',
        timestamp: new Date(),
        source: 'dashboard-service'
      }],
      status: {
        healthy: false,
        uptime: 0,
        lastUpdate: new Date()
      },
      healthScore: 0,
      generatedAt: new Date()
    };
  }

  private sleep(ms: number): Promise&lt;void&gt; {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
  }
}
</code></pre>

<hr />
<h3>ä¿®å¾© 1.3: æ¸¬è©¦å ´æ™¯ C é‚è¼¯ä¿®æ­£</h3>
<p><strong>å•é¡Œä½ç½®:</strong> æ¸¬è©¦å ´æ™¯ C å¯¦ç¾<br />
<strong>åŸå•é¡Œ:</strong> å‡è¨­ç³»çµ±èƒ½å„ªé›…é™ç´šï¼Œå¯¦éš›æœƒæ‹‹å‡ºç•°å¸¸<br />
<strong>ä¿®å¾©æ–¹æ¡ˆ:</strong> ä¿®æ­£æ¸¬è©¦é‚è¼¯ï¼Œé©—è­‰çœŸæ­£çš„é™ç´šè¡Œç‚º</p>
<pre class="codehilite"><code class="language-typescript">async function testDataSourceFailure() {
  const dataFetcher = new FailingDataFetcher();
  const dashboardService = new DashboardService(dataFetcher);

  try {
    const dashboardData = await dashboardService.generateDashboard();

    // âœ… ç¾åœ¨é€™è£¡æ‡‰è©²èƒ½åŸ·è¡Œï¼Œå› ç‚ºæˆ‘å€‘å¯¦ç¾äº† fallback
    const isDegradedMode = dashboardData.healthScore === 0 &amp;&amp; 
                          dashboardData.status.healthy === false;
    const hasDegradedAlert = dashboardData.alerts.some(alert =&gt; 
      alert.message.includes('Data source unavailable')
    );

    const success = isDegradedMode &amp;&amp; hasDegradedAlert;

    console.log('âœ… Test C: Data Source Failure - ' + (success ? 'PASSED' : 'FAILED'));
    console.log('Fallback mechanism worked correctly');
    console.log(`System healthy: ${dashboardData.status.healthy}`);
    console.log(`Health Score: ${dashboardData.healthScore}%`);
    console.log(`Degraded alert present: ${hasDegradedAlert}`);

    return { success, data: dashboardData };

  } catch (error) {
    // âŒ å¦‚æœé‚„æœ‰éŒ¯èª¤ï¼Œèªªæ˜ä¿®å¾©ä¸å®Œæ•´
    console.log('âŒ Test C: Data Source Failure - FAILED');
    console.log('Fallback mechanism not working:', error.message);
    return { success: false, error: error.message };
  }
}
</code></pre>

<hr />
<h2>ğŸ”§ Phase 2: ä¸­å„ªå…ˆç´šæ”¹é€²</h2>
<h3>æ”¹é€² 2.1: å¥åº·è©•åˆ†ç®—æ³•å„ªåŒ–</h3>
<p><strong>å•é¡Œä½ç½®:</strong> calculateHealthScore æ–¹æ³•<br />
<strong>åŸå•é¡Œ:</strong> è¶…éé–¾å€¼ 5% å°±è®Š 0 åˆ†ï¼Œéæ–¼åš´æ ¼<br />
<strong>æ”¹é€²æ–¹æ¡ˆ:</strong> ä½¿ç”¨æ›´å¹³æ»‘çš„è©•åˆ†å‡½æ•¸</p>
<pre class="codehilite"><code class="language-typescript">private calculateHealthScore(metrics: Map&lt;string, Metric&gt;): number {
  let totalScore = 0;
  let weightCount = 0;

  metrics.forEach((metric) =&gt; {
    if (metric.threshold) {
      const usageRatio = metric.value / metric.threshold;
      let score: number;

      if (usageRatio &lt;= 1) {
        // æœªè¶…éé–¾å€¼ï¼šç·šæ€§è©•åˆ† 100-60 åˆ†
        score = 100 - (usageRatio * 40);
      } else {
        // è¶…éé–¾å€¼ï¼šç·šæ€§ç½°åˆ†ï¼Œæ¯è¶…é 1% æ‰£ 5 åˆ†
        const overagePercentage = (usageRatio - 1) * 100;
        score = Math.max(0, 60 - (overagePercentage * 5));
      }

      totalScore += score;
      weightCount++;
    }
  });

  return weightCount &gt; 0 ? Math.round(totalScore / weightCount) : 100;
}
</code></pre>

<p><strong>ç®—æ³•èªªæ˜ï¼š</strong>
- æœªè¶…éé–¾å€¼ï¼šè©•åˆ†å¾ 100 åˆ†ç·šæ€§é™è‡³ 60 åˆ†
- è¶…éé–¾å€¼ï¼šå¾ 60 åˆ†é–‹å§‹ï¼Œæ¯è¶…é 1% æ‰£ 5 åˆ†
- æœ€ä½åˆ†æ•¸ç‚º 0 åˆ†ï¼Œç¢ºä¿è©•åˆ†ç¯„åœåœ¨ 0-100 ä¹‹é–“</p>
<hr />
<h3>æ”¹é€² 2.2: XSS å®‰å…¨é˜²è­·</h3>
<p><strong>å•é¡Œä½ç½®:</strong> SimpleHTMLDashboard æ¸²æŸ“æ–¹æ³•<br />
<strong>åŸå•é¡Œ:</strong> HTML æœªè½‰ç¾©ï¼Œå­˜åœ¨ XSS é¢¨éšª<br />
<strong>æ”¹é€²æ–¹æ¡ˆ:</strong> å¯¦ç¾ HTML è½‰ç¾©å‡½æ•¸</p>
<pre class="codehilite"><code class="language-typescript">class SimpleHTMLDashboard implements DashboardView {

  /**
   * HTML è½‰ç¾©å‡½æ•¸ï¼Œé˜²æ­¢ XSS æ”»æ“Š
   */
  private escapeHtml(unsafe: string): string {
    return unsafe
      .replace(/&amp;/g, &quot;&amp;amp;&quot;)
      .replace(/&lt;/g, &quot;&amp;lt;&quot;)
      .replace(/&gt;/g, &quot;&amp;gt;&quot;)
      .replace(/&quot;/g, &quot;&amp;quot;&quot;)
      .replace(/'/g, &quot;&amp;#039;&quot;)
      .replace(/\//g, &quot;&amp;#x2F;&quot;);
  }

  private renderMetrics(metrics: Map&lt;string, Metric&gt;): string {
    let html = '';
    metrics.forEach((metric) =&gt; {
      const status = metric.threshold &amp;&amp; metric.value &gt; metric.threshold ? 'âš ï¸' : 'âœ…';
      html += `
        &lt;div class=&quot;metric&quot;&gt;
            &lt;h4&gt;${this.escapeHtml(metric.name)} ${status}&lt;/h4&gt;
            &lt;p&gt;&lt;strong&gt;${this.escapeHtml(metric.value.toString())}${this.escapeHtml(metric.unit)}&lt;/strong&gt;&lt;/p&gt;
            ${metric.threshold ? `&lt;p&gt;Threshold: ${this.escapeHtml(metric.threshold.toString())}${this.escapeHtml(metric.unit)}&lt;/p&gt;` : ''}
        &lt;/div&gt;`;
    });
    return html;
  }

  private renderAlerts(alerts: Alert[]): string {
    if (alerts.length === 0) {
      return '&lt;p&gt;No recent alerts&lt;/p&gt;';
    }

    return alerts.map(alert =&gt; `
        &lt;div class=&quot;alert alert-${alert.level}&quot;&gt;
            &lt;strong&gt;${this.escapeHtml(alert.level.toUpperCase())}:&lt;/strong&gt; ${this.escapeHtml(alert.message)}
            &lt;br&gt;&lt;small&gt;${this.escapeHtml(alert.timestamp.toLocaleString())} - ${this.escapeHtml(alert.source)}&lt;/small&gt;
        &lt;/div&gt;
    `).join('');
  }

  render(data: DashboardData): string {
    const healthColor = data.healthScore &gt; 80 ? 'green' : 
                       data.healthScore &gt; 60 ? 'orange' : 'red';

    return `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;System Dashboard&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .health-score { font-size: 24px; font-weight: bold; color: ${healthColor}; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .metric { padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .alerts { margin: 20px 0; }
        .alert { padding: 10px; margin: 5px 0; border-radius: 3px; }
        .alert-warning { background-color: #fff3cd; border: 1px solid #ffeaa7; }
        .alert-info { background-color: #d1ecf1; border: 1px solid #bee5eb; }
        .alert-error { background-color: #f8d7da; border: 1px solid #f5c6cb; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;header&quot;&gt;
        &lt;h1&gt;System Dashboard&lt;/h1&gt;
        &lt;div&gt;
            &lt;span&gt;Health Score: &lt;/span&gt;
            &lt;span class=&quot;health-score&quot;&gt;${this.escapeHtml(data.healthScore.toString())}%&lt;/span&gt;
            &lt;button onclick=&quot;location.reload()&quot;&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;metrics&quot;&gt;
        ${this.renderMetrics(data.metrics)}
    &lt;/div&gt;

    &lt;div class=&quot;alerts&quot;&gt;
        &lt;h3&gt;Recent Alerts&lt;/h3&gt;
        ${this.renderAlerts(data.alerts)}
    &lt;/div&gt;

    &lt;div class=&quot;status&quot;&gt;
        &lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; ${data.status.healthy ? 'Healthy' : 'Unhealthy'}&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Uptime:&lt;/strong&gt; ${this.escapeHtml(data.status.uptime.toString())}%&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Last Update:&lt;/strong&gt; ${this.escapeHtml(data.status.lastUpdate.toLocaleString())}&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`;
  }
}
</code></pre>

<hr />
<h3>æ”¹é€² 2.3: é‚Šç•Œæ¢ä»¶æ¸¬è©¦</h3>
<p><strong>å•é¡Œä½ç½®:</strong> æ¸¬è©¦å ´æ™¯<br />
<strong>åŸå•é¡Œ:</strong> ç¼ºå°‘é‚Šç•Œæ¢ä»¶æ¸¬è©¦<br />
<strong>æ”¹é€²æ–¹æ¡ˆ:</strong> æ·»åŠ å®Œæ•´çš„é‚Šç•Œæ¢ä»¶æ¸¬è©¦</p>
<pre class="codehilite"><code class="language-typescript">async function testBoundaryConditions() {
  console.log('ğŸ§ª Test: Boundary Conditions');
  const results: any[] = [];

  // æ¸¬è©¦ 1: ç©ºæ•¸æ“šé›†
  try {
    class EmptyDataFetcher implements DataFetcher {
      async fetchMetrics(): Promise&lt;Map&lt;string, Metric&gt;&gt; {
        return new Map();
      }

      async fetchAlerts(): Promise&lt;Alert[]&gt; {
        return [];
      }

      async fetchStatus(): Promise&lt;Status&gt; {
        return {
          healthy: true,
          uptime: 100,
          lastUpdate: new Date()
        };
      }
    }

    const emptyService = new DashboardService(new EmptyDataFetcher());
    const emptyData = await emptyService.generateDashboard();

    results.push({
      test: 'Empty Dataset',
      success: emptyData.metrics.size === 0 &amp;&amp; 
               emptyData.alerts.length === 0 &amp;&amp;
               emptyData.healthScore === 100,
      details: `Metrics: ${emptyData.metrics.size}, Alerts: ${emptyData.alerts.length}, Score: ${emptyData.healthScore}`
    });

  } catch (error) {
    results.push({ test: 'Empty Dataset', success: false, error: error.message });
  }

  // æ¸¬è©¦ 2: æ¥µå¤§æ•¸å€¼
  try {
    class LargeValueDataFetcher extends MockDataFetcher {
      async fetchMetrics(): Promise&lt;Map&lt;string, Metric&gt;&gt; {
        const metrics = await super.fetchMetrics();
        const cpuMetric = metrics.get('cpu');
        if (cpuMetric) {
          cpuMetric.value = Number.MAX_SAFE_INTEGER;
        }
        return metrics;
      }
    }

    const largeService = new DashboardService(new LargeValueDataFetcher());
    const largeData = await largeService.generateDashboard();

    results.push({
      test: 'Large Values',
      success: typeof largeData.healthScore === 'number' &amp;&amp; 
               largeData.healthScore &gt;= 0 &amp;&amp; 
               largeData.healthScore &lt;= 100,
      details: `Health Score: ${largeData.healthScore}`
    });

  } catch (error) {
    results.push({ test: 'Large Values', success: false, error: error.message });
  }

  // æ¸¬è©¦ 3: è² æ•¸å€¼
  try {
    class NegativeValueDataFetcher extends MockDataFetcher {
      async fetchMetrics(): Promise&lt;Map&lt;string, Metric&gt;&gt; {
        const metrics = await super.fetchMetrics();
        const cpuMetric = metrics.get('cpu');
        if (cpuMetric) {
          cpuMetric.value = -10;
        }
        return metrics;
      }
    }

    const negativeService = new DashboardService(new NegativeValueDataFetcher());
    const negativeData = await negativeService.generateDashboard();

    results.push({
      test: 'Negative Values',
      success: typeof negativeData.healthScore === 'number' &amp;&amp; 
               negativeData.healthScore &gt;= 0 &amp;&amp; 
               negativeData.healthScore &lt;= 100,
      details: `Health Score: ${negativeData.healthScore}`
    });

  } catch (error) {
    results.push({ test: 'Negative Values', success: false, error: error.message });
  }

  // æ¸¬è©¦ 4: null/undefined å€¼è™•ç†
  try {
    class NullValueDataFetcher extends MockDataFetcher {
      async fetchStatus(): Promise&lt;Status&gt; {
        return {
          healthy: true,
          uptime: null as any, // æ¨¡æ“¬ null å€¼
          lastUpdate: new Date()
        };
      }
    }

    const nullService = new DashboardService(new NullValueDataFetcher());
    const nullData = await nullService.generateDashboard();

    results.push({
      test: 'Null Values',
      success: nullData !== null &amp;&amp; nullData !== undefined,
      details: 'System handled null values without crashing'
    });

  } catch (error) {
    results.push({ test: 'Null Values', success: false, error: error.message });
  }

  // è¼¸å‡ºæ¸¬è©¦çµæœ
  console.log('ğŸ“Š Boundary Conditions Results:');
  results.forEach(result =&gt; {
    const status = result.success ? 'âœ… PASSED' : 'âŒ FAILED';
    console.log(`  ${result.test}: ${status}`);
    if (result.details) console.log(`    Details: ${result.details}`);
    if (result.error) console.log(`    Error: ${result.error}`);
  });

  const allPassed = results.every(r =&gt; r.success);
  console.log(`\nOverall: ${allPassed ? 'âœ… ALL TESTS PASSED' : 'âŒ SOME TESTS FAILED'}`);

  return { success: allPassed, results };
}
</code></pre>

<hr />
<h2>ğŸ“Š ä¿®å¾©å¾Œçš„å®Œæ•´æ¸¬è©¦å ´æ™¯</h2>
<h3>å ´æ™¯ A: æ­£å¸¸é¡¯ç¤ºæ¸¬è©¦ (ä¿æŒä¸è®Š)</h3>
<pre class="codehilite"><code class="language-typescript">async function testNormalDisplay() {
  const dataFetcher = new MockDataFetcher();
  const dashboardService = new DashboardService(dataFetcher);
  const dashboardView = new SimpleHTMLDashboard();

  const dashboardData = await dashboardService.generateDashboard();
  const html = dashboardView.render(dashboardData);

  console.log('âœ… Test A: Normal Display - PASSED');
  console.log('Dashboard generated successfully');
  console.log(`Health Score: ${dashboardData.healthScore}%`);
  console.log(`Metrics count: ${dashboardData.metrics.size}`);
  console.log(`Alerts count: ${dashboardData.alerts.length}`);

  return { success: true, data: dashboardData, html };
}
</code></pre>

<h3>å ´æ™¯ B: å‘Šè­¦è§¸ç™¼æ¸¬è©¦ (å·²ä¿®å¾©æ‹¼å¯«éŒ¯èª¤)</h3>
<pre class="codehilite"><code class="language-typescript">class HighCPUMockDataFetcher extends MockDataFetcher {
  async fetchMetrics(): Promise&lt;Map&lt;string, Metric&gt;&gt; {
    const metrics = await super.fetchMetrics();
    const cpuMetric = metrics.get('cpu');
    if (cpuMetric) {
      cpuMetric.value = 85; // è¶…éé–¾å€¼ 80%
    }
    return metrics;
  }
}

async function testAlertTrigger() {
  const dataFetcher = new HighCPUMockDataFetcher(); // âœ… ä¿®æ­£æ‹¼å¯«éŒ¯èª¤
  const dashboardService = new DashboardService(dataFetcher);
  const dashboardView = new SimpleHTMLDashboard();

  const dashboardData = await dashboardService.generateDashboard();
  const html = dashboardView.render(dashboardData);

  const cpuMetric = dashboardData.metrics.get('cpu');
  const isAlertTriggered = cpuMetric &amp;&amp; cpuMetric.value &gt; cpuMetric.threshold!;
  const hasWarningIcon = html.includes('âš ï¸');
  const healthScoreLower = dashboardData.healthScore &lt; 100;

  const passed = isAlertTriggered &amp;&amp; hasWarningIcon &amp;&amp; healthScoreLower;

  console.log('âœ… Test B: Alert Trigger - ' + (passed ? 'PASSED' : 'FAILED'));
  console.log(`CPU Usage: ${cpuMetric?.value}% (Threshold: ${cpuMetric?.threshold}%)`);
  console.log(`Health Score: ${dashboardData.healthScore}%`);
  console.log(`Warning Icon Present: ${hasWarningIcon}`);

  return { success: passed, data: dashboardData, html };
}
</code></pre>

<h3>å ´æ™¯ C: æ•¸æ“šæºæ•…éšœæ¸¬è©¦ (å·²ä¿®æ­£é‚è¼¯)</h3>
<pre class="codehilite"><code class="language-typescript">class FailingDataFetcher implements DataFetcher {
  async fetchMetrics(): Promise&lt;Map&lt;string, Metric&gt;&gt; {
    throw new Error('Data source unavailable');
  }

  async fetchAlerts(): Promise&lt;Alert[]&gt; {
    return [];
  }

  async fetchStatus(): Promise&lt;Status&gt; {
    return {
      healthy: false,
      uptime: 0,
      lastUpdate: new Date()
    };
  }
}

async function testDataSourceFailure() {
  const dataFetcher = new FailingDataFetcher();
  const dashboardService = new DashboardService(dataFetcher);

  try {
    const dashboardData = await dashboardService.generateDashboard();

    const isDegradedMode = dashboardData.healthScore === 0 &amp;&amp; 
                          dashboardData.status.healthy === false;
    const hasDegradedAlert = dashboardData.alerts.some(alert =&gt; 
      alert.message.includes('Data source unavailable')
    );

    const success = isDegradedMode &amp;&amp; hasDegradedAlert;

    console.log('âœ… Test C: Data Source Failure - ' + (success ? 'PASSED' : 'FAILED'));
    console.log('Fallback mechanism worked correctly');
    console.log(`System healthy: ${dashboardData.status.healthy}`);
    console.log(`Health Score: ${dashboardData.healthScore}%`);
    console.log(`Degraded alert present: ${hasDegradedAlert}`);

    return { success, data: dashboardData };

  } catch (error) {
    console.log('âŒ Test C: Data Source Failure - FAILED');
    console.log('Fallback mechanism not working:', error.message);
    return { success: false, error: error.message };
  }
}
</code></pre>

<hr />
<h2>ğŸš€ å®Œæ•´åŸ·è¡Œæµç¨‹ (æ›´æ–°)</h2>
<pre class="codehilite"><code class="language-typescript">async function runAllTests() {
  console.log('ğŸš€ Starting Dashboard Test Strategy Implementation (Fixed)\n');

  // åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦å ´æ™¯
  const testResults = await Promise.allSettled([
    testNormalDisplay(),
    testAlertTrigger(), 
    testDataSourceFailure(),
    testBoundaryConditions() // æ–°å¢é‚Šç•Œæ¢ä»¶æ¸¬è©¦
  ]);

  // è¼¸å‡ºæ¸¬è©¦çµæœ
  console.log('\nğŸ“Š Test Results Summary:');
  const testNames = ['Normal Display', 'Alert Trigger', 'Data Source Failure', 'Boundary Conditions'];

  testResults.forEach((result, index) =&gt; {
    const testName = testNames[index];
    if (result.status === 'fulfilled') {
      const testResult = result.value;
      console.log(`${testName}: ${testResult.success ? 'âœ… PASSED' : 'âŒ FAILED'}`);
    } else {
      console.log(`${testName}: âŒ FAILED - ${result.reason}`);
    }
  });

  // ç”Ÿæˆç¤ºä¾‹ Dashboard HTML
  console.log('\nğŸ“„ Generating sample dashboard...');
  const normalResult = await testNormalDisplay();

  // ä¿å­˜ HTML åˆ°æ–‡ä»¶
  const fs = require('fs');
  const path = require('path');

  const outputPath = path.join(process.cwd(), 'dashboard-test-fixed.html');
  fs.writeFileSync(outputPath, normalResult.html);

  console.log(`âœ… Dashboard HTML saved to: ${outputPath}`);
  console.log('ğŸ‰ Dashboard Test Strategy Implementation (Fixed) Complete!');
}

// åŸ·è¡Œæ¸¬è©¦
if (require.main === module) {
  runAllTests().catch(console.error);
}
</code></pre>

<hr />
<h2>ğŸ“ ä¿®å¾©å¾Œé©—æ”¶æ¨™æº–</h2>
<h3>âœ… Phase 1 é—œéµå•é¡Œé©—æ”¶</h3>
<ul>
<li>[x] <strong>æ‹¼å¯«éŒ¯èª¤ä¿®æ­£</strong> - HighCPUMockockDataFetcher â†’ HighCPUMockDataFetcher</li>
<li>[x] <strong>éŒ¯èª¤è™•ç†ç­–ç•¥å¯¦ç¾</strong> - Retry (3æ¬¡ï¼ŒæŒ‡æ•¸é€€é¿)ã€Fallback (ç·©å­˜)ã€Degraded Mode</li>
<li>[x] <strong>æ¸¬è©¦å ´æ™¯ C ä¿®æ­£</strong> - é©—è­‰çœŸæ­£çš„é™ç´šè¡Œç‚ºï¼Œè€Œéç•°å¸¸æ•ç²</li>
</ul>
<h3>âœ… Phase 2 ä¸­å„ªå…ˆç´šæ”¹é€²é©—æ”¶</h3>
<ul>
<li>[x] <strong>å¥åº·è©•åˆ†ç®—æ³•å„ªåŒ–</strong> - ä½¿ç”¨å¹³æ»‘è©•åˆ†å‡½æ•¸ï¼Œé¿å…éæ–¼åš´æ ¼</li>
<li>[x] <strong>XSS å®‰å…¨é˜²è­·</strong> - å¯¦ç¾ HTML è½‰ç¾©å‡½æ•¸ï¼Œä¿è­·æ‰€æœ‰å‹•æ…‹å…§å®¹</li>
<li>[x] <strong>é‚Šç•Œæ¢ä»¶æ¸¬è©¦</strong> - æ·»åŠ ç©ºæ•¸æ“šé›†ã€æ¥µå¤§æ•¸å€¼ã€è² æ•¸ã€null/undefined æ¸¬è©¦</li>
</ul>
<h3>âœ… åŠŸèƒ½é©—æ”¶</h3>
<ul>
<li>[x] Dashboard èƒ½æ­£ç¢ºé¡¯ç¤ºæ¨¡æ“¬æ•¸æ“š</li>
<li>[x] å‘Šè­¦è¦å‰‡æ­£ç¢ºè§¸ç™¼ï¼ˆCPU &gt; 80% é¡¯ç¤ºè­¦å‘Šï¼‰</li>
<li>[x] å¥åº·è©•åˆ†æº–ç¢ºè¨ˆç®—ï¼ˆåŸºæ–¼å¹³æ»‘ç®—æ³•ï¼‰</li>
<li>[x] éŒ¯èª¤è™•ç†æ©Ÿåˆ¶æ­£å¸¸å·¥ä½œï¼ˆæ•¸æ“šæºæ•…éšœæ™‚å„ªé›…é™ç´šï¼‰</li>
<li>[x] å®‰å…¨é˜²è­·ç”Ÿæ•ˆï¼ˆHTML å…§å®¹æ­£ç¢ºè½‰ç¾©ï¼‰</li>
</ul>
<h3>âœ… æ¶æ§‹é©—æ”¶</h3>
<ul>
<li>[x] éµå¾ªå±¤ç´šæ¶æ§‹åŸå‰‡ï¼ˆData Access â†’ Business Logic â†’ Presentationï¼‰</li>
<li>[x] æ¥å£èˆ‡å¯¦ç¾åˆ†é›¢ï¼ˆDataFetcher interface vs MockDataFetcherï¼‰</li>
<li>[x] çµ„ä»¶é–“é¬†è€¦åˆï¼ˆé€šéä¾è³´æ³¨å…¥ï¼‰</li>
<li>[x] éŒ¯èª¤è™•ç†ç­–ç•¥å®Œæ•´ï¼ˆRetryã€Fallbackã€Degraded Modeï¼‰</li>
</ul>
<h3>âœ… æ¸¬è©¦é©—æ”¶</h3>
<ul>
<li>[x] æä¾›äº†å®Œæ•´çš„å–®å…ƒæ¸¬è©¦å ´æ™¯</li>
<li>[x] é›†æˆæ¸¬è©¦è¦†è“‹ä¸»è¦æµç¨‹</li>
<li>[x] é‚Šç•Œæ¢ä»¶æ¸¬è©¦è¦†è“‹ç•°å¸¸æƒ…æ³</li>
<li>[x] æ‰‹å‹•æ¸¬è©¦å¯é€šéé‹è¡Œ <code>runAllTests()</code></li>
<li>[x] ç”Ÿæˆå¯è¦–åŒ– HTML è¼¸å‡ºä¾›é©—è­‰</li>
</ul>
<hr />
<h2>ğŸ” ä¿®å¾©å‰åå°æ¯”</h2>
<table>
<thead>
<tr>
<th>é …ç›®</th>
<th>ä¿®å¾©å‰</th>
<th>ä¿®å¾©å¾Œ</th>
<th>æ”¹é€²</th>
</tr>
</thead>
<tbody>
<tr>
<td>æ‹¼å¯«éŒ¯èª¤</td>
<td>HighCPUMockockDataFetcher</td>
<td>HighCPUMockDataFetcher</td>
<td>âœ… ä»£ç¢¼å¯æ­£å¸¸é‹è¡Œ</td>
</tr>
<tr>
<td>éŒ¯èª¤è™•ç†</td>
<td>ç›´æ¥æ‹‹å‡ºç•°å¸¸</td>
<td>Retry + Fallback + Degraded Mode</td>
<td>âœ… å„ªé›…é™ç´š</td>
</tr>
<tr>
<td>å¥åº·è©•åˆ†</td>
<td>è¶…éé–¾å€¼ 5% å³ç‚º 0 åˆ†</td>
<td>å¹³æ»‘ç·šæ€§è©•åˆ†ç®—æ³•</td>
<td>âœ… åˆç†è©•åˆ†</td>
</tr>
<tr>
<td>å®‰å…¨é˜²è­·</td>
<td>HTML æœªè½‰ç¾©</td>
<td>å®Œæ•´è½‰ç¾©å‡½æ•¸</td>
<td>âœ… é˜²æ­¢ XSS</td>
</tr>
<tr>
<td>é‚Šç•Œæ¸¬è©¦</td>
<td>ç¼ºå°‘é‚Šç•Œæ¢ä»¶æ¸¬è©¦</td>
<td>å®Œæ•´é‚Šç•Œæ¢ä»¶è¦†è“‹</td>
<td>âœ… å¥å£¯æ€§æå‡</td>
</tr>
<tr>
<td>æ¸¬è©¦å ´æ™¯ C</td>
<td>é‚è¼¯éŒ¯èª¤</td>
<td>æ­£ç¢ºé©—è­‰é™çº§è¡Œç‚º</td>
<td>âœ… æ¸¬è©¦æœ‰æ•ˆæ€§</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“ˆ å¥åº·è©•åˆ†ç®—æ³•ç¤ºä¾‹</h2>
<h3>ä¿®å¾©å‰ç®—æ³•</h3>
<pre class="codehilite"><code>CPU = 85%, threshold = 80%
è¨ˆç®—: 100 - (85/80) * 100 = 100 - 106.25 = -6.25
çµæœ: Math.max(0, -6.25) = 0
å•é¡Œ: è¶…é 5% å°±è®Šç‚º 0 åˆ†ï¼Œéæ–¼åš´æ ¼
</code></pre>

<h3>ä¿®å¾©å¾Œç®—æ³•</h3>
<pre class="codehilite"><code>CPU = 85%, threshold = 80%
è¨ˆç®—: overagePercentage = (85/80 - 1) * 100 = 6.25%
çµæœ: 60 - (6.25 * 5) = 60 - 31.25 = 28.75 â‰ˆ 29 åˆ†
å„ªé»: å¹³æ»‘è©•åˆ†ï¼Œæ›´åˆç†åæ˜ ç³»çµ±ç‹€æ…‹
</code></pre>

<hr />
<h2>ğŸ¯ åŸ·è¡ŒæŒ‡å—</h2>
<h3>å¿«é€Ÿé©—è­‰</h3>
<pre class="codehilite"><code class="language-bash"># 1. ç¢ºä¿ Node.js ç’°å¢ƒ
node --version

# 2. é‹è¡Œä¿®å¾©å¾Œçš„æ¸¬è©¦
node -e &quot;eval(require('fs').readFileSync('dashboard-fixed.js', 'utf8'))&quot;

# 3. æŸ¥çœ‹ç”Ÿæˆçš„ Dashboard
open dashboard-test-fixed.html
</code></pre>

<h3>æ¸¬è©¦å ´æ™¯é©—è­‰</h3>
<ol>
<li><strong>æ­£å¸¸é¡¯ç¤º</strong>: æ‰“é–‹ dashboard-test-fixed.htmlï¼Œé©—è­‰æ‰€æœ‰çµ„ä»¶æ­£å¸¸é¡¯ç¤º</li>
<li><strong>å‘Šè­¦è§¸ç™¼</strong>: æª¢æŸ¥ CPU æŒ‡æ¨™æ˜¯å¦é¡¯ç¤ºè­¦å‘Šæ¨™è­˜ âš ï¸ï¼Œå¥åº·åˆ†æ•¸æ˜¯å¦åˆç†é™ä½</li>
<li><strong>æ•¸æ“šæºæ•…éšœ</strong>: ä¿®æ”¹ä»£ç¢¼ä½¿ç”¨ FailingDataFetcherï¼Œé©—è­‰é™ç´šæ¨¡å¼é¡¯ç¤º</li>
<li><strong>å®‰å…¨æ¸¬è©¦</strong>: åœ¨ HTML å…§å®¹ä¸­æ³¨å…¥ç‰¹æ®Šå­—ç¬¦ï¼Œé©—è­‰æ­£ç¢ºè½‰ç¾©</li>
<li><strong>é‚Šç•Œæ¢ä»¶</strong>: é‹è¡Œé‚Šç•Œæ¢ä»¶æ¸¬è©¦ï¼Œç¢ºä¿æ‰€æœ‰ç•°å¸¸æƒ…æ³æ­£ç¢ºè™•ç†</li>
</ol>
<hr />
<h2>ğŸ”§ æ“´å±•å»ºè­°</h2>
<h3>ä¸‹ä¸€æ­¥æ”¹é€²</h3>
<ol>
<li><strong>çœŸå¯¦æ•¸æ“šæºé›†æˆ</strong>: å¯¦ç¾ APIDataFetcher é€£æ¥å¯¦éš› API</li>
<li><strong>å¯¦æ™‚æ›´æ–°</strong>: æ·»åŠ  WebSocket æ”¯æŒå¯¦æ™‚æ•¸æ“šæ¨é€</li>
<li><strong>å¯è¦–åŒ–å¢å¼·</strong>: é›†æˆ Chart.js æˆ– D3.js å‹•æ…‹åœ–è¡¨</li>
<li><strong>é…ç½®ç®¡ç†</strong>: æ·»åŠ é…ç½®æ–‡ä»¶æ”¯æŒè‡ªå®šç¾©é–¾å€¼å’ŒæŒ‡æ¨™</li>
<li><strong>ç›£æ§é›†æˆ</strong>: æ·»åŠ æ€§èƒ½ç›£æ§å’Œæ—¥èªŒè¨˜éŒ„</li>
</ol>
<h3>ç”Ÿç”¢å°±ç·’æ­¥é©Ÿ</h3>
<ol>
<li>æ·»åŠ æ›´å®Œå–„çš„éŒ¯èª¤ç›£æ§å’Œæ—¥èªŒè¨˜éŒ„</li>
<li>å¯¦ç¾åˆ†å¸ƒå¼ç·©å­˜æ©Ÿåˆ¶</li>
<li>æ·»åŠ ç”¨æˆ¶èªè­‰å’Œæˆæ¬Š</li>
<li>éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒä¸¦é€²è¡Œå£“åŠ›æ¸¬è©¦</li>
</ol>
<hr />
<p><strong>ä¿®å¾©ç‰ˆæœ¬:</strong> v1.1<br />
<strong>ä¿®å¾©æ™‚é–“:</strong> ~45 åˆ†é˜<br />
<strong>æ¸¬è©¦ç‹€æ…‹:</strong> å…¨éƒ¨é€šé<br />
<strong>ç‹€æ…‹:</strong> âœ… ä¿®å¾©å®Œæˆï¼Œæº–å‚™å°±ç·’</p>
<hr />
<p><em>æœ¬å ±å‘Šéµå¾ª agent-output skill å”è­°ç”Ÿæˆ</em></p>
        <p class="footer">Generated: 2026-02-22 11:29:12</p>
        <a href="index.html" class="back-link">â† Back to Index</a>
    </div>
</body>
</html>
