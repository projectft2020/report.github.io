<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>波動率適應性趨勢跟隮 - 量化交易研究報告</title>
    
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --accent-color: #f59e0b;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --text-color: #1e293b;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --code-bg: #1e293b;
            --code-text: #e2e8f0;
            --table-header: #f1f5f9;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 3rem 2rem;
            border-radius: 16px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        
        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 0.5rem;
        }
        
        .header .description {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        .content {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }
        
        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {
            color: var(--primary-color);
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        
        .content h1 { font-size: 2.2rem; }
        .content h2 { font-size: 1.8rem; }
        .content h3 { font-size: 1.5rem; }
        .content h4 { font-size: 1.3rem; }
        .content h5 { font-size: 1.1rem; }
        .content h6 { font-size: 1rem; }
        
        .content p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        
        .content ul, .content ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }
        
        .content li {
            margin-bottom: 0.5rem;
        }
        
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content th, .content td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }
        
        .content th {
            background-color: var(--table-header);
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .content tr:nth-child(even) {
            background-color: #f8fafc;
        }
        
        .content blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--secondary-color);
            font-style: italic;
        }
        
        .content code {
            background-color: #f1f5f9;
            color: var(--primary-color);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        
        .content pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .content pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }
        
        .back-to-home {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }
        
        .back-to-home:hover {
            background: #1d4ed8;
            transform: translateX(-4px);
        }
        
        .footer {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            margin-top: 2rem;
            border-top: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .footer p {
            color: var(--secondary-color);
            margin-bottom: 0.5rem;
        }
        
        .footer .disclaimer {
            font-size: 0.875rem;
            font-style: italic;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }
        
        .info-box {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .success-box {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .header {
                padding: 2rem 1rem;
            }
            
            .content {
                padding: 1.5rem;
            }
            
            .content h1 { font-size: 1.8rem; }
            .content h2 { font-size: 1.5rem; }
            .content h3 { font-size: 1.3rem; }
        }
    </style>
    
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-to-home">← 返回研究目錄</a>
        
        <div class="header">
            <h1>波動率適應性趨勢跟隮</h1>
            <p class="subtitle">量化交易研究報告 - 2026-02-19</p>
            <p class="description">四種波動率測量方法 + 五級波動率分類 + Kelly 公式集成</p>
        </div>
        
        <div class="content">
            <h1 id="_1">波動率適應性趨勢跟隮策略<a class="headerlink" href="#_1" title="連結到此標題">&para;</a></h1>
<p><strong>Task ID:</strong> t004-volatility-adaptive
<strong>Agent:</strong> Charlie Analyst
<strong>Status:</strong> completed
<strong>Timestamp:</strong> 2026-02-19T14:15:00+08:00</p>
<h2 id="_2">研究目標<a class="headerlink" href="#_2" title="連結到此標題">&para;</a></h2>
<p>開發根據市場波動率動態調整趨勢跟隮策略的頭寸大小和參數的系統，實現策略對市場狀態變化的適應性，提高策略穩定性和收益風險比。</p>
<h2 id="_3">核心概念<a class="headerlink" href="#_3" title="連結到此標題">&para;</a></h2>
<h3 id="_4">為什麼需要波動率適應性？<a class="headerlink" href="#_4" title="連結到此標題">&para;</a></h3>
<p>市場波動率隨時間劇烈變化，固定參數的策略在不同波動率環境下表現不穩定：</p>
<p><strong>高波動市場：</strong>
- 價格波動劇烈，容易觸發止損
- 需要更寬的止損距離
- 應該降低倉位以控制風險
- 趨勢強度閾值需要提高（避免假信號）</p>
<p><strong>低波動市場：</strong>
- 價格波動平緩，趨勢更穩定
- 可以使用更緊的止損
- 可以增加倉位以提高收益
- 趨勢強度閾值可以降低（捕捉更多機會）</p>
<h3 id="_5">波動率適應性框架<a class="headerlink" href="#_5" title="連結到此標題">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────┐
│     波動率測量（多種方法）                         │
│     - 標準差                                      │
│     - ATR                                         │
│     - Parkinson 波動率                            │
│     - Garman-Klass 波動率                         │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│     波動率分級                                    │
│     - 極低 (&lt;0.5%)                                 │
│     - 低 (0.5-1.0%)                               │
│     - 中等 (1.0-2.0%)                             │
│     - 高 (2.0-3.5%)                               │
│     - 極高 (&gt;3.5%)                                │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│     適應性調整                                    │
│     - 頭寸調整                                    │
│     - 止損調整                                    │
│     - 趨勢強度閾值調整                            │
│     - 其他參數調整                                │
└─────────────────────────────────────────────────┘
</code></pre>
<h2 id="_6">波動率測量方法<a class="headerlink" href="#_6" title="連結到此標題">&para;</a></h2>
<h3 id="1-standard-deviation">1. 標準差（Standard Deviation）<a class="headerlink" href="#1-standard-deviation" title="連結到此標題">&para;</a></h3>
<p><strong>公式：</strong></p>
<pre><code>σ = sqrt(Σ(rt - r̄)² / (n-1))
</code></pre>
<p>其中：
- rt = 第 t 日的收益率
- r̄ = 平均收益率
- n = 樣本數量</p>
<p><strong>優點：</strong>
- 計算簡單直觀
- 廣泛使用
- 容易解釋</p>
<p><strong>缺點：</strong>
- 假設收益率常態分佈（實際非正態）
- 對極端值敏感
- 不考慮高點和低點的信息</p>
<p><strong>實現：</strong></p>
<pre><code class="language-python">def calculate_std_volatility(returns, window=20):
    &quot;&quot;&quot;
    計算標準差波動率

    Parameters:
    -----------
    returns : pd.Series
        收益率序列
    window : int
        計算窗口

    Returns:
    --------
    pd.Series
        波動率序列
    &quot;&quot;&quot;
    return returns.rolling(window=window).std()
</code></pre>
<h3 id="2-atraverage-true-range">2. ATR（Average True Range）<a class="headerlink" href="#2-atraverage-true-range" title="連結到此標題">&para;</a></h3>
<p><strong>True Range 公式：</strong></p>
<pre><code>TR = max(High-Low, |High-Close_prev|, |Low-Close_prev|)
</code></pre>
<p><strong>ATR 公式：</strong></p>
<pre><code>ATR = SMA(TR, n)
</code></pre>
<p><strong>優點：</strong>
- 考慮了跳空（gaps）
- 不假設常態分佈
- 廣泛用於止損設置</p>
<p><strong>缺點：</strong>
- 對跳空過度敏感
- 在平穩市場可能高估波動
- 滯後性</p>
<p><strong>實現：</strong></p>
<pre><code class="language-python">def calculate_atr(data, period=14):
    &quot;&quot;&quot;
    計算 ATR (Average True Range)

    Parameters:
    -----------
    data : pd.DataFrame
        包含 'High', 'Low', 'Close' 的數據
    period : int
        ATR 週期

    Returns:
    --------
    pd.Series
        ATR 序列
    &quot;&quot;&quot;
    high = data['High']
    low = data['Low']
    close = data['Close']

    # 計算 True Range
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    # 計算 ATR（使用 RMA - Wilder's smoothing）
    atr = tr.ewm(alpha=1/period, adjust=False).mean()

    return atr

def calculate_atr_volatility(data, window=14):
    &quot;&quot;&quot;
    計算基於 ATR 的波動率（百分比）

    Parameters:
    -----------
    data : pd.DataFrame
        價格數據
    window : int
        ATR 週期

    Returns:
    --------
    pd.Series
        波動率序列（百分比）
    &quot;&quot;&quot;
    atr = calculate_atr(data, window)
    return atr / data['Close'] * 100
</code></pre>
<h3 id="3-parkinson">3. Parkinson 波動率<a class="headerlink" href="#3-parkinson" title="連結到此標題">&para;</a></h3>
<p><strong>基於高低價的波動率，比收盤價波動率更有效</strong></p>
<p><strong>公式：</strong></p>
<pre><code>σ_P² = (1 / (4n * ln(2))) * Σ(ln(Hi/Li))²
</code></pre>
<p><strong>優點：</strong>
- 使用了高點和低點的信息
- 比收盤價波動率更有效（估計方差更小）
- 對開盤跳空不敏感</p>
<p><strong>缺點：</strong>
- 忽略了開盤價和收盤價的信息
- 不適合跳空較大的市場
- 低估真實波動率（因為假設連續交易）</p>
<p><strong>實現：</strong></p>
<pre><code class="language-python">def calculate_parkinson_volatility(data, window=20):
    &quot;&quot;&quot;
    計算 Parkinson 波動率

    Parameters:
    -----------
    data : pd.DataFrame
        包含 'High', 'Low' 的數據
    window : int
        計算窗口

    Returns:
    --------
    pd.Series
        Parkinson 波動率（年化）
    &quot;&quot;&quot;
    high = data['High']
    low = data['Low']

    # 計算 ln(H/L)
    log_hl = np.log(high / low)

    # Parkinson 公式
    parkinson_sq = (log_hl ** 2).rolling(window=window).sum()
    parkinson_vol = np.sqrt(parkinson_sq / (4 * window * np.log(2)))

    # 年化（假設 252 個交易日）
    parkinson_vol_annual = parkinson_vol * np.sqrt(252)

    return parkinson_vol_annual
</code></pre>
<h3 id="4-garman-klass">4. Garman-Klass 波動率<a class="headerlink" href="#4-garman-klass" title="連結到此標題">&para;</a></h3>
<p><strong>綜合開高低收的最優估計</strong></p>
<p><strong>公式：</strong></p>
<pre><code>σ_GK² = (0.511 * (ln(H/L))²) - (0.019 * ln(C/O) * ln(HL*O²)) - (2 * (1.414 - 1) * ln(C/O))²
</code></pre>
<p>簡化版：</p>
<pre><code>σ_GK² = (0.5 * (ln(H/L))²) - (2 * ln(2) - 1) * (ln(C/O))²
</code></pre>
<p><strong>優點：</strong>
- 使用所有價格信息（開高低收）
- 理論上是最有效的估計
- 比 Parkinson 波動率更準確</p>
<p><strong>缺點：</strong>
- 計算複雜
- 對數據質量要求高
- 對跳空仍然敏感</p>
<p><strong>實現：</strong></p>
<pre><code class="language-python">def calculate_garmanklass_volatility(data, window=20):
    &quot;&quot;&quot;
    計算 Garman-Klass 波動率

    Parameters:
    -----------
    data : pd.DataFrame
        包含 'Open', 'High', 'Low', 'Close' 的數據
    window : int
        計算窗口

    Returns:
    --------
    pd.Series
        Garman-Klass 波動率（年化）
    &quot;&quot;&quot;
    high = data['High']
    low = data['Low']
    open_ = data['Open']
    close = data['Close']

    # Garman-Klass 公式
    log_hl = np.log(high / low)
    log_co = np.log(close / open_)

    gk_sq = (0.5 * log_hl ** 2) - (2 * np.log(2) - 1) * (log_co ** 2)

    # 滾動平均
    gk_vol_sq = gk_sq.rolling(window=window).mean()

    # 取平方根並年化
    gk_vol = np.sqrt(gk_vol_sq) * np.sqrt(252)

    return gk_vol
</code></pre>
<h2 id="_7">波動率測量方法對比<a class="headerlink" href="#_7" title="連結到此標題">&para;</a></h2>
<h3 id="_8">比較表<a class="headerlink" href="#_8" title="連結到此標題">&para;</a></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>數據需求</th>
<th>效率</th>
<th>靈敏度</th>
<th>跳空處理</th>
<th>計算複雜度</th>
<th>推薦場景</th>
</tr>
</thead>
<tbody>
<tr>
<td>標準差</td>
<td>Close</td>
<td>低</td>
<td>中</td>
<td>差</td>
<td>低</td>
<td>一般分析</td>
</tr>
<tr>
<td>ATR</td>
<td>HLC</td>
<td>中</td>
<td>高</td>
<td>好</td>
<td>低</td>
<td>止損設置</td>
</tr>
<tr>
<td>Parkinson</td>
<td>HL</td>
<td>高</td>
<td>中</td>
<td>差</td>
<td>中</td>
<td>日內交易</td>
</tr>
<tr>
<td>Garman-Klass</td>
<td>OHLC</td>
<td>最高</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>精確估計</td>
</tr>
</tbody>
</table>
<h3 id="_9">性能特徵<a class="headerlink" href="#_9" title="連結到此標題">&para;</a></h3>
<h4 id="1">1. 對跳空的反應<a class="headerlink" href="#1" title="連結到此標題">&para;</a></h4>
<pre><code>跳空發生時：
- 標準差：跳空被視為正常波動
- ATR：顯著增加（捕獲跳空）
- Parkinson：忽略跳空（只用高點低點）
- Garman-Klass：部分捕獲（考慮開盤價）

結論：ATR 最適合需要考慮跳空的場景
</code></pre>
<h4 id="2">2. 對極端值敏感度<a class="headerlink" href="#2" title="連結到此標題">&para;</a></h4>
<pre><code>極端價格出現時：
- 標準差：非常敏感（離群值影響大）
- ATR：中度敏感（平滑處理）
- Parkinson：中度敏感（依賴高點低點）
- Garman-Klass：較不敏感（綜合多個價格）

結論：Garman-Klass 更穩定，標準差最敏感
</code></pre>
<h4 id="3">3. 估計效率（方差大小）<a class="headerlink" href="#3" title="連結到此標題">&para;</a></h4>
<pre><code>估計效率排序（從高到低）：
1. Garman-Klass（使用所有價格信息）
2. Parkinson（使用高低價信息）
3. 標準差（只使用收盤價）

結論：Garman-Klass 理論上最優
</code></pre>
<h3 id="_10">使用建議<a class="headerlink" href="#_10" title="連結到此標題">&para;</a></h3>
<h4 id="_11">綜合使用策略<a class="headerlink" href="#_11" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">def calculate_combined_volatility(data, window=20):
    &quot;&quot;&quot;
    計算綜合波動率（結合多種方法）

    使用加權組合，權重根據市場環境動態調整

    Parameters:
    -----------
    data : pd.DataFrame
        價格數據
    window : int
        計算窗口

    Returns:
    --------
    dict
        包含各種波動率的字典
    &quot;&quot;&quot;
    # 計算各種波動率
    std_vol = calculate_std_volatility(data['Close'].pct_change(), window) * 100
    atr_vol = calculate_atr_volatility(data, window)
    parkinson_vol = calculate_parkinson_volatility(data, window)
    gk_vol = calculate_garmanklass_volatility(data, window)

    # 計算權重（基於歷史相關性）
    # 這裡使用簡化權重，實際應該優化
    weights = {
        'std': 0.2,
        'atr': 0.3,
        'parkinson': 0.2,
        'gk': 0.3
    }

    # 加權平均（年化波動率需要轉換到日波動率）
    combined_vol = (
        std_vol * weights['std'] +
        atr_vol * weights['atr'] +
        parkinson_vol / np.sqrt(252) * 100 * weights['parkinson'] +
        gk_vol / np.sqrt(252) * 100 * weights['gk']
    )

    return {
        'std': std_vol,
        'atr': atr_vol,
        'parkinson': parkinson_vol,
        'gk': gk_vol,
        'combined': combined_vol,
        'weights': weights
    }
</code></pre>
<h4 id="_12">根據場景選擇<a class="headerlink" href="#_12" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">def select_volatility_method(market_regime, data, window=20):
    &quot;&quot;&quot;
    根據市場狀態選擇波動率測量方法

    Parameters:
    -----------
    market_regime : str
        市場狀態 ('trending', 'ranging', 'high_vol', 'low_vol')
    data : pd.DataFrame
        價格數據
    window : int
        計算窗口

    Returns:
    --------
    str
        推薦的波動率方法
    &quot;&quot;&quot;
    if market_regime == 'high_vol':
        # 高波動：使用 ATR（捕獲跳空）
        return 'atr'
    elif market_regime == 'low_vol':
        # 低波動：使用 Garman-Klass（精確估計）
        return 'gk'
    elif market_regime == 'trending':
        # 趨勢市場：使用 Parkinson（不受跳空影響）
        return 'parkinson'
    else:
        # 默認：使用綜合波動率
        return 'combined'
</code></pre>
<h2 id="_13">波動率分級系統<a class="headerlink" href="#_13" title="連結到此標題">&para;</a></h2>
<h3 id="_14">分級標準<a class="headerlink" href="#_14" title="連結到此標題">&para;</a></h3>
<table>
<thead>
<tr>
<th>級別</th>
<th>波動率範圍</th>
<th>市場特徵</th>
<th>頭寸比例</th>
<th>止損倍數</th>
<th>趨勢閾值</th>
</tr>
</thead>
<tbody>
<tr>
<td>極低</td>
<td>&lt; 0.5%</td>
<td>平穩，缺乏波動</td>
<td>120%</td>
<td>0.8x</td>
<td>50</td>
</tr>
<tr>
<td>低</td>
<td>0.5-1.0%</td>
<td>平穩，有輕微波動</td>
<td>100%</td>
<td>1.0x</td>
<td>55</td>
</tr>
<tr>
<td>中等</td>
<td>1.0-2.0%</td>
<td>正常波動</td>
<td>80%</td>
<td>1.5x</td>
<td>60</td>
</tr>
<tr>
<td>高</td>
<td>2.0-3.5%</td>
<td>波動較大</td>
<td>50%</td>
<td>2.5x</td>
<td>70</td>
</tr>
<tr>
<td>極高</td>
<td>&gt; 3.5%</td>
<td>極端波動，風險高</td>
<td>25%</td>
<td>3.5x</td>
<td>80</td>
</tr>
</tbody>
</table>
<h3 id="_15">波動率分類器實現<a class="headerlink" href="#_15" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">from enum import Enum
from typing import Dict, Tuple, Optional

class VolatilityLevel(Enum):
    &quot;&quot;&quot;波動率級別枚舉&quot;&quot;&quot;
    EXTREMELY_LOW = &quot;極低&quot;
    LOW = &quot;低&quot;
    MEDIUM = &quot;中等&quot;
    HIGH = &quot;高&quot;
    EXTREMELY_HIGH = &quot;極高&quot;

class VolatilityClassifier:
    &quot;&quot;&quot;
    波動率分類器

    將波動率分類為不同級別，並提供相應的調整建議
    &quot;&quot;&quot;

    def __init__(self,
                 thresholds: Optional[Dict[str, float]] = None):
        &quot;&quot;&quot;
        初始化分類器

        Parameters:
        -----------
        thresholds : dict, optional
            自定義閾值，格式為：
            {
                'extremely_low': 0.5,
                'low': 1.0,
                'medium': 2.0,
                'high': 3.5
            }
        &quot;&quot;&quot;
        self.thresholds = thresholds or {
            'extremely_low': 0.5,
            'low': 1.0,
            'medium': 2.0,
            'high': 3.5
        }

        # 頭寸調整策略
        self.position_multipliers = {
            VolatilityLevel.EXTREMELY_LOW: 1.20,
            VolatilityLevel.LOW: 1.00,
            VolatilityLevel.MEDIUM: 0.80,
            VolatilityLevel.HIGH: 0.50,
            VolatilityLevel.EXTREMELY_HIGH: 0.25
        }

        # 止損距離調整（ATR 乘數）
        self.stop_loss_multipliers = {
            VolatilityLevel.EXTREMELY_LOW: 0.8,
            VolatilityLevel.LOW: 1.0,
            VolatilityLevel.MEDIUM: 1.5,
            VolatilityLevel.HIGH: 2.5,
            VolatilityLevel.EXTREMELY_HIGH: 3.5
        }

        # 趨勢強度閾值調整
        self.trend_thresholds = {
            VolatilityLevel.EXTREMELY_LOW: 50,
            VolatilityLevel.LOW: 55,
            VolatilityLevel.MEDIUM: 60,
            VolatilityLevel.HIGH: 70,
            VolatilityLevel.EXTREMELY_HIGH: 80
        }

    def classify(self, volatility: float) -&gt; VolatilityLevel:
        &quot;&quot;&quot;
        分類波動率

        Parameters:
        -----------
        volatility : float
            波動率（百分比）

        Returns:
        --------
        VolatilityLevel
            波動率級別
        &quot;&quot;&quot;
        if volatility &lt; self.thresholds['extremely_low']:
            return VolatilityLevel.EXTREMELY_LOW
        elif volatility &lt; self.thresholds['low']:
            return VolatilityLevel.LOW
        elif volatility &lt; self.thresholds['medium']:
            return VolatilityLevel.MEDIUM
        elif volatility &lt; self.thresholds['high']:
            return VolatilityLevel.HIGH
        else:
            return VolatilityLevel.EXTREMELY_HIGH

    def get_position_multiplier(self, volatility_level: VolatilityLevel) -&gt; float:
        &quot;&quot;&quot;
        獲取頭寸倍數

        Parameters:
        -----------
        volatility_level : VolatilityLevel
            波動率級別

        Returns:
        --------
        float
            頭寸倍數
        &quot;&quot;&quot;
        return self.position_multipliers[volatility_level]

    def get_stop_loss_multiplier(self, volatility_level: VolatilityLevel) -&gt; float:
        &quot;&quot;&quot;
        獲取止損距離倍數

        Parameters:
        -----------
        volatility_level : VolatilityLevel
            波動率級別

        Returns:
        --------
        float
            止損距離倍數
        &quot;&quot;&quot;
        return self.stop_loss_multipliers[volatility_level]

    def get_trend_threshold(self, volatility_level: VolatilityLevel) -&gt; int:
        &quot;&quot;&quot;
        獲取趨勢強度閾值

        Parameters:
        -----------
        volatility_level : VolatilityLevel
            波動率級別

        Returns:
        --------
        int
            趨勢強度閾值
        &quot;&quot;&quot;
        return self.trend_thresholds[volatility_level]

    def get_adjustments(self, volatility: float) -&gt; Dict:
        &quot;&quot;&quot;
        獲取完整的調整建議

        Parameters:
        -----------
        volatility : float
            波動率（百分比）

        Returns:
        --------
        dict
            調整建議
        &quot;&quot;&quot;
        level = self.classify(volatility)

        return {
            'volatility': volatility,
            'level': level.value,
            'position_multiplier': self.get_position_multiplier(level),
            'stop_loss_multiplier': self.get_stop_loss_multiplier(level),
            'trend_threshold': self.get_trend_threshold(level),
            'description': self._get_description(level)
        }

    def _get_description(self, level: VolatilityLevel) -&gt; str:
        &quot;&quot;&quot;
        獲取級別描述

        Parameters:
        -----------
        level : VolatilityLevel
            波動率級別

        Returns:
        --------
        str
            描述信息
        &quot;&quot;&quot;
        descriptions = {
            VolatilityLevel.EXTREMELY_LOW: &quot;極低波動：市場平穩，可以增加倉位，使用緊密止損&quot;,
            VolatilityLevel.LOW: &quot;低波動：市場平穩，標準倉位，正常止損&quot;,
            VolatilityLevel.MEDIUM: &quot;中等波動：市場正常，降低倉位，放寬止損&quot;,
            VolatilityLevel.HIGH: &quot;高波動：市場波動劇烈，顯著降低倉位，使用寬止損&quot;,
            VolatilityLevel.EXTREMELY_HIGH: &quot;極高波動：市場極端，最小倉位，極寬止損，謹慎交易&quot;
        }

        return descriptions[level]

    def update_thresholds(self, new_thresholds: Dict[str, float]):
        &quot;&quot;&quot;
        更新閾值

        Parameters:
        -----------
        new_thresholds : dict
            新閾值
        &quot;&quot;&quot;
        self.thresholds.update(new_thresholds)
</code></pre>
<h2 id="_16">頭寸調整策略<a class="headerlink" href="#_16" title="連結到此標題">&para;</a></h2>
<h3 id="1_1">1. 基於波動率的頭寸調整<a class="headerlink" href="#1_1" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class VolatilityPositionSizer:
    &quot;&quot;&quot;
    基於波動率的頭寸調整器

    根據市場波動率動態調整倉位大小
    &quot;&quot;&quot;

    def __init__(self,
                 classifier: VolatilityClassifier,
                 base_position_pct: float = 0.02,
                 max_position_pct: float = 0.05):
        &quot;&quot;&quot;
        初始化頭寸調整器

        Parameters:
        -----------
        classifier : VolatilityClassifier
            波動率分類器
        base_position_pct : float
            基礎倉位百分比（默認 2%）
        max_position_pct : float
            最大倉位百分比（默認 5%）
        &quot;&quot;&quot;
        self.classifier = classifier
        self.base_position_pct = base_position_pct
        self.max_position_pct = max_position_pct

    def calculate_position_size(self,
                                volatility: float,
                                account_balance: float,
                                stop_loss_distance: float,
                                risk_per_trade: float = 0.02) -&gt; Dict:
        &quot;&quot;&quot;
        計算頭寸大小

        綜合考慮：
        1. 波動率分類建議
        2. 固定百分比風險
        3. 基於止損的風險控制

        Parameters:
        -----------
        volatility : float
            波動率（百分比）
        account_balance : float
            賬戶餘額
        stop_loss_distance : float
            止損距離（絕對值）
        risk_per_trade : float
            每筆交易最大風險（默認 2%）

        Returns:
        --------
        dict
            頭寸信息
        &quot;&quot;&quot;
        # 獲取波動率調整
        adjustments = self.classifier.get_adjustments(volatility)
        vol_multiplier = adjustments['position_multiplier']

        # 方法 1：基於固定百分比
        position_pct_1 = self.base_position_pct * vol_multiplier
        position_size_1 = account_balance * position_pct_1

        # 方法 2：基於風險（止損）
        risk_amount = account_balance * risk_per_trade
        position_size_2 = risk_amount / stop_loss_distance

        # 方法 3：綜合（取較小值）
        position_size = min(position_size_1, position_size_2)

        # 限制最大倉位
        max_position_size = account_balance * self.max_position_pct
        position_size = min(position_size, max_position_size)

        return {
            'position_size': position_size,
            'position_pct': position_size / account_balance,
            'volatility': volatility,
            'volatility_level': adjustments['level'],
            'vol_multiplier': vol_multiplier,
            'method': 'combined',
            'risk_amount': risk_amount,
            'stop_loss_distance': stop_loss_distance
        }
</code></pre>
<h3 id="2-kelly">2. Kelly 公式頭寸調整<a class="headerlink" href="#2-kelly" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class KellyPositionSizer:
    &quot;&quot;&quot;
    Kelly 公式頭寸調整器

    優化長期增長率的頭寸大小
    &quot;&quot;&quot;

    def __init__(self,
                 win_rate: float = 0.60,
                 avg_win: float = 0.03,
                 avg_loss: float = 0.02,
                 kelly_fraction: float = 0.5):
        &quot;&quot;&quot;
        初始化 Kelly 公式調整器

        Parameters:
        -----------
        win_rate : float
            勝率（0-1）
        avg_win : float
            平均獲利比例
        avg_loss : float
            平均虧損比例
        kelly_fraction : float
            Kelly 分數（降低實際使用比例，默認 0.5）
        &quot;&quot;&quot;
        self.win_rate = win_rate
        self.avg_win = avg_win
        self.avg_loss = avg_loss
        self.kelly_fraction = kelly_fraction

    def calculate_kelly_fraction(self) -&gt; float:
        &quot;&quot;&quot;
        計算 Kelly 分數

        公式：f* = (bp - q) / b

        其中：
        - b = 盈虧比 (avg_win / avg_loss)
        - p = 勝率
        - q = 1 - p (敗率)

        Returns:
        --------
        float
            Kelly 分數（資金百分比）
        &quot;&quot;&quot;
        b = self.avg_win / self.avg_loss
        p = self.win_rate
        q = 1 - p

        kelly_f = (b * p - q) / b

        # 應用 Kelly 分數（通常不超過 Kelly 理論值的一半）
        adjusted_kelly = kelly_f * self.kelly_fraction

        # 確保非負
        return max(0, adjusted_kelly)

    def update_performance_stats(self,
                                  win_rate: float,
                                  avg_win: float,
                                  avg_loss: float):
        &quot;&quot;&quot;
        更新績效統計

        Parameters:
        -----------
        win_rate : float
            勝率
        avg_win : float
            平均獲利
        avg_loss : float
            平均虧損
        &quot;&quot;&quot;
        self.win_rate = win_rate
        self.avg_win = avg_win
        self.avg_loss = avg_loss

    def calculate_position_size(self,
                                volatility: float,
                                account_balance: float,
                                stop_loss_distance: float) -&gt; Dict:
        &quot;&quot;&quot;
        使用 Kelly 公式計算頭寸

        Parameters:
        -----------
        volatility : float
            波動率（百分比）
        account_balance : float
            賬戶餘額
        stop_loss_distance : float
            止損距離

        Returns:
        --------
        dict
            頭寸信息
        &quot;&quot;&quot;
        # 計算 Kelly 分數
        kelly_pct = self.calculate_kelly_fraction()

        # 波動率調整（高波動降低 Kelly 倉位）
        vol_adjustment = min(1.0, 1.5 / max(volatility, 0.5))  # 波動率越高，調整越強
        adjusted_kelly_pct = kelly_pct * vol_adjustment

        # 計算頭寸大小
        position_size = account_balance * adjusted_kelly_pct

        # 基於止損的風險檢查
        risk_pct = (position_size * stop_loss_distance) / account_balance

        return {
            'position_size': position_size,
            'position_pct': adjusted_kelly_pct,
            'kelly_pct': kelly_pct,
            'vol_adjustment': vol_adjustment,
            'risk_pct': risk_pct,
            'method': 'kelly'
        }
</code></pre>
<h3 id="3_1">3. 綜合頭寸調整<a class="headerlink" href="#3_1" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class AdaptivePositionSizer:
    &quot;&quot;&quot;
    適應性頭寸調整器

    結合波動率調整和 Kelly 公式
    &quot;&quot;&quot;

    def __init__(self,
                 classifier: VolatilityClassifier,
                 base_position_pct: float = 0.02,
                 kelly_fraction: float = 0.5,
                 use_kelly: bool = True,
                 kelly_weight: float = 0.5):
        &quot;&quot;&quot;
        初始化綜合調整器

        Parameters:
        -----------
        classifier : VolatilityClassifier
            波動率分類器
        base_position_pct : float
            基礎倉位百分比
        kelly_fraction : float
            Kelly 分數
        use_kelly : bool
            是否使用 Kelly 公式
        kelly_weight : float
            Kelly 公式權重（0-1）
        &quot;&quot;&quot;
        self.classifier = classifier
        self.base_position_pct = base_position_pct

        # 波動率調整器
        self.vol_sizer = VolatilityPositionSizer(
            classifier=classifier,
            base_position_pct=base_position_pct
        )

        # Kelly 調整器
        self.kelly_sizer = KellyPositionSizer(
            kelly_fraction=kelly_fraction
        )

        self.use_kelly = use_kelly
        self.kelly_weight = kelly_weight

    def calculate_position_size(self,
                                volatility: float,
                                account_balance: float,
                                stop_loss_distance: float,
                                win_rate: Optional[float] = None,
                                avg_win: Optional[float] = None,
                                avg_loss: Optional[float] = None) -&gt; Dict:
        &quot;&quot;&quot;
        綜合計算頭寸大小

        Parameters:
        -----------
        volatility : float
            波動率（百分比）
        account_balance : float
            賬戶餘額
        stop_loss_distance : float
            止損距離
        win_rate : float, optional
            勝率（用於 Kelly 公式）
        avg_win : float, optional
            平均獲利（用於 Kelly 公式）
        avg_loss : float, optional
            平均虧損（用於 Kelly 公式）

        Returns:
        --------
        dict
            頭寸信息
        &quot;&quot;&quot;
        # 波動率調整
        vol_result = self.vol_sizer.calculate_position_size(
            volatility=volatility,
            account_balance=account_balance,
            stop_loss_distance=stop_loss_distance
        )

        # Kelly 調整
        if self.use_kelly and win_rate is not None:
            # 更新 Kelly 統計
            self.kelly_sizer.update_performance_stats(
                win_rate=win_rate,
                avg_win=avg_win or 0.03,
                avg_loss=avg_loss or 0.02
            )

            kelly_result = self.kelly_sizer.calculate_position_size(
                volatility=volatility,
                account_balance=account_balance,
                stop_loss_distance=stop_loss_distance
            )

            # 綜合兩種方法
            vol_pct = vol_result['position_pct']
            kelly_pct = kelly_result['position_pct']

            final_pct = (vol_pct * (1 - self.kelly_weight) +
                        kelly_pct * self.kelly_weight)

            final_size = account_balance * final_pct

            method = f&quot;combined_vol_kelly_{self.kelly_weight}&quot;

            return {
                'position_size': final_size,
                'position_pct': final_pct,
                'volatility_result': vol_result,
                'kelly_result': kelly_result,
                'method': method,
                'kelly_weight': self.kelly_weight
            }
        else:
            # 只使用波動率調整
            return {
                **vol_result,
                'method': 'volatility_only'
            }
</code></pre>
<h2 id="_17">參數適應性調整<a class="headerlink" href="#_17" title="連結到此標題">&para;</a></h2>
<h3 id="1_2">1. 止損距離調整<a class="headerlink" href="#1_2" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def calculate_adaptive_stop_loss(data: pd.DataFrame,
                                  volatility: float,
                                  classifier: VolatilityClassifier,
                                  atr_period: int = 14) -&gt; Dict:
    &quot;&quot;&quot;
    計算適應性止損距離

    Parameters:
    -----------
    data : pd.DataFrame
        價格數據
    volatility : float
        波動率（百分比）
    classifier : VolatilityClassifier
        波動率分類器
    atr_period : int
        ATR 週期

    Returns:
    --------
    dict
        止損信息
    &quot;&quot;&quot;
    # 計算 ATR
    atr = calculate_atr(data, atr_period)

    # 獲取波動率調整
    adjustments = classifier.get_adjustments(volatility)
    stop_multiplier = adjustments['stop_loss_multiplier']

    # 計算止損距離
    current_atr = atr.iloc[-1]
    stop_distance = current_atr * stop_multiplier

    # 計算百分比距離
    current_price = data['Close'].iloc[-1]
    stop_distance_pct = (stop_distance / current_price) * 100

    return {
        'atr': current_atr,
        'stop_multiplier': stop_multiplier,
        'stop_distance': stop_distance,
        'stop_distance_pct': stop_distance_pct,
        'volatility_level': adjustments['level'],
        'current_price': current_price
    }
</code></pre>
<h3 id="2_1">2. 趨勢強度閾值調整<a class="headerlink" href="#2_1" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def calculate_adaptive_trend_threshold(volatility: float,
                                        classifier: VolatilityClassifier) -&gt; Dict:
    &quot;&quot;&quot;
    計算適應性趨勢強度閾值

    Parameters:
    -----------
    volatility : float
        波動率（百分比）
    classifier : VolatilityClassifier
        波動率分類器

    Returns:
    --------
    dict
        閾值信息
    &quot;&quot;&quot;
    # 獲取波動率調整
    adjustments = classifier.get_adjustments(volatility)
    trend_threshold = adjustments['trend_threshold']

    return {
        'threshold': trend_threshold,
        'volatility': volatility,
        'volatility_level': adjustments['level'],
        'description': f&quot;波動率 {volatility:.2f}%：趨勢強度閾值調整為 {trend_threshold}&quot;
    }
</code></pre>
<h3 id="3_2">3. 其他參數調整<a class="headerlink" href="#3_2" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def calculate_adaptive_parameters(volatility: float,
                                   classifier: VolatilityClassifier,
                                   base_params: Dict) -&gt; Dict:
    &quot;&quot;&quot;
    計算完整的適應性參數

    Parameters:
    -----------
    volatility : float
        波動率（百分比）
    classifier : VolatilityClassifier
        波動率分類器
    base_params : dict
        基礎參數

    Returns:
    --------
    dict
        適應性參數
    &quot;&quot;&quot;
    # 獲取波動率調整
    adjustments = classifier.get_adjustments(volatility)
    level = adjustments['level']

    # 參數調整規則
    adaptive_params = base_params.copy()

    # 1. 趨勢強度閾值
    adaptive_params['min_trend_strength'] = adjustments['trend_threshold']

    # 2. ADX 閾值（高波動提高 ADX 閾值）
    if level in [VolatilityLevel.HIGH.value, VolatilityLevel.EXTREMELY_HIGH.value]:
        adaptive_params['min_adx'] = base_params['min_adx'] * 1.2
    elif level in [VolatilityLevel.LOW.value, VolatilityLevel.EXTREMELY_LOW.value]:
        adaptive_params['min_adx'] = base_params['min_adx'] * 0.8

    # 3. 持倉時間（高波動縮短持倉時間）
    if level == VolatilityLevel.EXTREMELY_HIGH.value:
        adaptive_params['max_hold_days'] = int(base_params['max_hold_days'] * 0.5)
    elif level == VolatilityLevel.HIGH.value:
        adaptive_params['max_hold_days'] = int(base_params['max_hold_days'] * 0.7)
    elif level == VolatilityLevel.LOW.value:
        adaptive_params['max_hold_days'] = int(base_params['max_hold_days'] * 1.3)
    elif level == VolatilityLevel.EXTREMELY_LOW.value:
        adaptive_params['max_hold_days'] = int(base_params['max_hold_days'] * 1.5)

    # 4. 確認次數（高波動需要更多確認）
    if level == VolatilityLevel.EXTREMELY_HIGH.value:
        adaptive_params['min_confirmations'] = base_params['min_confirmations'] + 1

    return {
        'volatility': volatility,
        'volatility_level': level,
        'base_params': base_params,
        'adaptive_params': adaptive_params,
        'adjustments': adjustments
    }
</code></pre>
<h2 id="_18">完整的波動率適應性系統<a class="headerlink" href="#_18" title="連結到此標題">&para;</a></h2>
<h3 id="_19">系統架構<a class="headerlink" href="#_19" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class VolatilityAdaptiveSystem:
    &quot;&quot;&quot;
    波動率適應性趨勢跟隮策略系統

    整合所有波動率適應性功能
    &quot;&quot;&quot;

    def __init__(self,
                 volatility_method: str = 'combined',
                 use_kelly: bool = True,
                 kelly_fraction: float = 0.5,
                 base_position_pct: float = 0.02):
        &quot;&quot;&quot;
        初始化系統

        Parameters:
        -----------
        volatility_method : str
            波動率測量方法 ('std', 'atr', 'parkinson', 'gk', 'combined')
        use_kelly : bool
            是否使用 Kelly 公式
        kelly_fraction : float
            Kelly 分數
        base_position_pct : float
            基礎倉位百分比
        &quot;&quot;&quot;
        self.volatility_method = volatility_method

        # 初始化波動率分類器
        self.classifier = VolatilityClassifier()

        # 初始化頭寸調整器
        self.position_sizer = AdaptivePositionSizer(
            classifier=self.classifier,
            base_position_pct=base_position_pct,
            kelly_fraction=kelly_fraction,
            use_kelly=use_kelly,
            kelly_weight=0.5
        )

        # 系統狀態
        self.current_volatility = None
        self.current_level = None
        self.current_adjustments = None

        # 歷史記錄
        self.history = []

    def calculate_volatility(self, data: pd.DataFrame, window: int = 20) -&gt; Dict:
        &quot;&quot;&quot;
        計算波動率

        Parameters:
        -----------
        data : pd.DataFrame
            價格數據
        window : int
            計算窗口

        Returns:
        --------
        dict
            波動率信息
        &quot;&quot;&quot;
        if self.volatility_method == 'std':
            volatility = calculate_std_volatility(
                data['Close'].pct_change(), window
            ).iloc[-1] * 100

        elif self.volatility_method == 'atr':
            volatility = calculate_atr_volatility(data, window).iloc[-1]

        elif self.volatility_method == 'parkinson':
            volatility = calculate_parkinson_volatility(data, window).iloc[-1]
            # 轉換為日波動率（百分比）
            volatility = volatility / np.sqrt(252) * 100

        elif self.volatility_method == 'gk':
            volatility = calculate_garmanklass_volatility(data, window).iloc[-1]
            # 轉換為日波動率（百分比）
            volatility = volatility / np.sqrt(252) * 100

        elif self.volatility_method == 'combined':
            combined = calculate_combined_volatility(data, window)
            volatility = combined['combined'].iloc[-1]

        else:
            raise ValueError(f&quot;未知的波動率方法：{self.volatility_method}&quot;)

        self.current_volatility = volatility

        return {
            'method': self.volatility_method,
            'volatility': volatility,
            'window': window
        }

    def analyze_market_state(self, data: pd.DataFrame,
                             window: int = 20) -&gt; Dict:
        &quot;&quot;&quot;
        分析市場狀態

        Parameters:
        -----------
        data : pd.DataFrame
            價格數據
        window : int
            計算窗口

        Returns:
        --------
        dict
            市場狀態分析
        &quot;&quot;&quot;
        # 計算波動率
        volatility_info = self.calculate_volatility(data, window)

        # 分類波動率
        level = self.classifier.classify(volatility_info['volatility'])
        self.current_level = level

        # 獲取調整建議
        adjustments = self.classifier.get_adjustments(volatility_info['volatility'])
        self.current_adjustments = adjustments

        # 記錄歷史
        self.history.append({
            'timestamp': data.index[-1],
            'volatility': volatility_info['volatility'],
            'level': level.value,
            'adjustments': adjustments
        })

        return {
            'volatility': volatility_info,
            'level': level,
            'adjustments': adjustments,
            'description': adjustments['description']
        }

    def calculate_position(self,
                          account_balance: float,
                          data: pd.DataFrame,
                          stop_loss_distance: float,
                          win_rate: Optional[float] = None,
                          avg_win: Optional[float] = None,
                          avg_loss: Optional[float] = None) -&gt; Dict:
        &quot;&quot;&quot;
        計算頭寸大小

        Parameters:
        -----------
        account_balance : float
            賬戶餘額
        data : pd.DataFrame
            價格數據
        stop_loss_distance : float
            止損距離
        win_rate : float, optional
            勝率
        avg_win : float, optional
            平均獲利
        avg_loss : float, optional
            平均虧損

        Returns:
        --------
        dict
            頭寸信息
        &quot;&quot;&quot;
        # 確保已分析市場狀態
        if self.current_volatility is None:
            self.analyze_market_state(data)

        # 計算頭寸
        position_result = self.position_sizer.calculate_position_size(
            volatility=self.current_volatility,
            account_balance=account_balance,
            stop_loss_distance=stop_loss_distance,
            win_rate=win_rate,
            avg_win=avg_win,
            avg_loss=avg_loss
        )

        return {
            **position_result,
            'market_state': {
                'volatility': self.current_volatility,
                'level': self.current_level.value,
                'adjustments': self.current_adjustments
            }
        }

    def calculate_stop_loss(self, data: pd.DataFrame) -&gt; Dict:
        &quot;&quot;&quot;
        計算適應性止損

        Parameters:
        -----------
        data : pd.DataFrame
            價格數據

        Returns:
        --------
        dict
            止損信息
        &quot;&quot;&quot;
        # 確保已分析市場狀態
        if self.current_volatility is None:
            self.analyze_market_state(data)

        # 計算止損
        stop_loss_result = calculate_adaptive_stop_loss(
            data=data,
            volatility=self.current_volatility,
            classifier=self.classifier
        )

        return stop_loss_result

    def calculate_trend_threshold(self) -&gt; Dict:
        &quot;&quot;&quot;
        計算適應性趨勢閾值

        Returns:
        --------
        dict
            閾值信息
        &quot;&quot;&quot;
        if self.current_volatility is None:
            raise ValueError(&quot;請先分析市場狀態&quot;)

        return calculate_adaptive_trend_threshold(
            volatility=self.current_volatility,
            classifier=self.classifier
        )

    def get_system_status(self) -&gt; Dict:
        &quot;&quot;&quot;
        獲取系統狀態

        Returns:
        --------
        dict
            系統狀態
        &quot;&quot;&quot;
        return {
            'volatility_method': self.volatility_method,
            'current_volatility': self.current_volatility,
            'current_level': self.current_level.value if self.current_level else None,
            'current_adjustments': self.current_adjustments,
            'history_length': len(self.history),
            'kelly_enabled': self.position_sizer.use_kelly
        }

    def generate_report(self) -&gt; str:
        &quot;&quot;&quot;
        生成系統報告

        Returns:
        --------
        str
            報告內容
        &quot;&quot;&quot;
        if not self.history:
            return &quot;無歷史記錄&quot;

        latest = self.history[-1]

        report = f&quot;&quot;&quot;
波動率適應性系統報告
時間：{latest['timestamp']}

=== 當前市場狀態 ===
波動率：{latest['volatility']:.2f}%
級別：{latest['level']}
描述：{latest['adjustments']['description']}

=== 調整建議 ===
頭寸倍數：{latest['adjustments']['position_multiplier']:.2f}x
止損倍數：{latest['adjustments']['stop_loss_multiplier']:.2f}x
趨勢閾值：{latest['adjustments']['trend_threshold']}

=== 系統配置 ===
波動率方法：{self.volatility_method}
Kelly 公式：{'啟用' if self.position_sizer.use_kelly else '禁用'}
&quot;&quot;&quot;

        return report
</code></pre>
<h2 id="_20">使用範例<a class="headerlink" href="#_20" title="連結到此標題">&para;</a></h2>
<h3 id="1_3">1. 基本使用<a class="headerlink" href="#1_3" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">import yfinance as yf
import pandas as pd
import numpy as np

# 載入數據
ticker = &quot;AAPL&quot;
data = yf.download(ticker, start=&quot;2023-01-01&quot;, end=&quot;2024-12-31&quot;)

# 初始化系統
vas = VolatilityAdaptiveSystem(
    volatility_method='combined',
    use_kelly=True,
    kelly_fraction=0.5,
    base_position_pct=0.02
)

# 分析市場狀態
market_state = vas.analyze_market_state(data)
print(&quot;=&quot; * 60)
print(&quot;市場狀態分析&quot;)
print(&quot;=&quot; * 60)
print(f&quot;波動率：{market_state['volatility']['volatility']:.2f}%&quot;)
print(f&quot;級別：{market_state['level'].value}&quot;)
print(f&quot;描述：{market_state['description']}&quot;)
print()

# 計算頭寸
account_balance = 100000
stop_loss_distance = 2.0  # $2 止損

position = vas.calculate_position(
    account_balance=account_balance,
    data=data,
    stop_loss_distance=stop_loss_distance,
    win_rate=0.60,
    avg_win=0.03,
    avg_loss=0.02
)

print(&quot;=&quot; * 60)
print(&quot;頭寸計算&quot;)
print(&quot;=&quot; * 60)
print(f&quot;頭寸大小：${position['position_size']:.2f}&quot;)
print(f&quot;頭寸比例：{position['position_pct']*100:.2f}%&quot;)
print(f&quot;方法：{position['method']}&quot;)
print()

# 計算止損
stop_loss = vas.calculate_stop_loss(data)
print(&quot;=&quot; * 60)
print(&quot;止損設置&quot;)
print(&quot;=&quot; * 60)
print(f&quot;當前 ATR：${stop_loss['atr']:.2f}&quot;)
print(f&quot;止損倍數：{stop_loss['stop_multiplier']:.2f}x&quot;)
print(f&quot;止損距離：${stop_loss['stop_distance']:.2f}&quot;)
print(f&quot;止損距離：{stop_loss['stop_distance_pct']:.2f}%&quot;)
print()

# 計算趨勢閾值
trend_threshold = vas.calculate_trend_threshold()
print(&quot;=&quot; * 60)
print(&quot;趨勢閾值&quot;)
print(&quot;=&quot; * 60)
print(f&quot;趨勢強度閾值：{trend_threshold['threshold']}&quot;)
print()

# 生成報告
print(&quot;=&quot; * 60)
print(vas.generate_report())
</code></pre>
<h3 id="2_2">2. 回測集成<a class="headerlink" href="#2_2" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class BacktestWithVolatilityAdaptive:
    &quot;&quot;&quot;
    集成波動率適應性的回測器
    &quot;&quot;&quot;

    def __init__(self,
                 strategy,
                 initial_capital=100000):
        &quot;&quot;&quot;
        初始化回測器

        Parameters:
        -----------
        strategy : object
            趨勢策略對象
        initial_capital : float
            初始資金
        &quot;&quot;&quot;
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.position = 0
        self.trades = []
        self.equity_curve = []

        # 初始化波動率適應性系統
        self.vas = VolatilityAdaptiveSystem(
            volatility_method='combined',
            use_kelly=True
        )

    def run_backtest(self, data):
        &quot;&quot;&quot;
        運行回測

        Parameters:
        -----------
        data : pd.DataFrame
            價格數據

        Returns:
        --------
        dict
            回測結果
        &quot;&quot;&quot;
        for i in range(50, len(data)):  # 從第 50 個交易日開始
            current_data = data.iloc[:i+1]
            current_price = current_data['Close'].iloc[-1]
            current_time = current_data.index[-1]

            # 分析市場狀態
            market_state = self.vas.analyze_market_state(current_data)

            # 計算適應性止損
            stop_loss_info = self.vas.calculate_stop_loss(current_data)
            stop_loss_distance = stop_loss_info['stop_distance']

            # 計算適應性趨勢閾值
            trend_threshold_info = self.vas.calculate_trend_threshold()
            min_trend_strength = trend_threshold_info['threshold']

            # 更新策略參數
            self.strategy.min_trend_strength = min_trend_strength

            # 生成策略信號
            signal = self.strategy.generate_signal(current_data)

            # 計算適應性頭寸
            win_rate = self._calculate_win_rate()
            avg_win, avg_loss = self._calculate_avg_win_loss()

            position_result = self.vas.calculate_position(
                account_balance=self.current_capital,
                data=current_data,
                stop_loss_distance=stop_loss_distance,
                win_rate=win_rate,
                avg_win=avg_win,
                avg_loss=avg_loss
            )

            # 執行交易
            if signal['action'] == 'buy' and self.position &lt;= 0:
                self._execute_buy(
                    price=current_price,
                    time=current_time,
                    position_size=position_result['position_size'],
                    stop_loss=current_price - stop_loss_distance
                )
            elif signal['action'] == 'sell' and self.position &gt;= 0:
                self._execute_sell(
                    price=current_price,
                    time=current_time,
                    position_size=position_result['position_size'],
                    stop_loss=current_price + stop_loss_distance
                )

            # 檢查止損
            if self.position != 0:
                if self._check_stop_loss(current_price):
                    self._close_position(current_price, current_time, &quot;stop_loss&quot;)

            # 更新資金
            self._update_equity(current_price, current_time)

        # 計算績效
        performance = self._calculate_performance()

        return {
            'performance': performance,
            'trades': self.trades,
            'equity_curve': self.equity_curve,
            'volatility_history': self.vas.history
        }

    def _execute_buy(self, price, time, position_size, stop_loss):
        &quot;&quot;&quot;執行買入&quot;&quot;&quot;
        self.position = int(position_size / price)
        self.entry_price = price
        self.stop_loss = stop_loss

        self.trades.append({
            'timestamp': time,
            'action': 'buy',
            'entry_price': price,
            'position_size': self.position,
            'stop_loss': stop_loss
        })

    def _execute_sell(self, price, time, position_size, stop_loss):
        &quot;&quot;&quot;執行賣出&quot;&quot;&quot;
        self.position = -int(position_size / price)
        self.entry_price = price
        self.stop_loss = stop_loss

        self.trades.append({
            'timestamp': time,
            'action': 'sell',
            'entry_price': price,
            'position_size': abs(self.position),
            'stop_loss': stop_loss
        })

    def _close_position(self, price, time, reason):
        &quot;&quot;&quot;平倉&quot;&quot;&quot;
        if self.position != 0:
            pnl = self.position * (price - self.entry_price)
            self.current_capital += pnl

            if self.trades:
                self.trades[-1].update({
                    'exit_price': price,
                    'exit_time': time,
                    'pnl': pnl,
                    'exit_reason': reason
                })

            self.position = 0

    def _check_stop_loss(self, price):
        &quot;&quot;&quot;檢查止損&quot;&quot;&quot;
        if hasattr(self, 'stop_loss'):
            if self.position &gt; 0 and price &lt;= self.stop_loss:
                return True
            elif self.position &lt; 0 and price &gt;= self.stop_loss:
                return True
        return False

    def _update_equity(self, price, time):
        &quot;&quot;&quot;更新資金&quot;&quot;&quot;
        if self.position != 0:
            unrealized_pnl = self.position * (price - self.entry_price)
            equity = self.current_capital + unrealized_pnl
        else:
            equity = self.current_capital

        self.equity_curve.append({
            'timestamp': time,
            'equity': equity
        })

    def _calculate_win_rate(self):
        &quot;&quot;&quot;計算勝率&quot;&quot;&quot;
        completed_trades = [t for t in self.trades if 'pnl' in t]
        if not completed_trades:
            return 0.5

        winning_trades = [t for t in completed_trades if t['pnl'] &gt; 0]
        return len(winning_trades) / len(completed_trades)

    def _calculate_avg_win_loss(self):
        &quot;&quot;&quot;計算平均盈虧&quot;&quot;&quot;
        completed_trades = [t for t in self.trades if 'pnl' in t]
        if not completed_trades:
            return 0.03, 0.02

        winning_trades = [t for t in completed_trades if t['pnl'] &gt; 0]
        losing_trades = [t for t in completed_trades if t['pnl'] &lt; 0]

        avg_win = np.mean([t['pnl'] for t in winning_trades]) if winning_trades else 0.03
        avg_loss = abs(np.mean([t['pnl'] for t in losing_trades])) if losing_trades else 0.02

        return avg_win, avg_loss

    def _calculate_performance(self):
        &quot;&quot;&quot;計算回測績效&quot;&quot;&quot;
        if not self.equity_curve:
            return {}

        equity_series = pd.Series([e['equity'] for e in self.equity_curve])
        returns = equity_series.pct_change().dropna()

        total_return = (self.current_capital / self.initial_capital - 1) * 100

        running_max = equity_series.expanding().max()
        drawdown = (equity_series - running_max) / running_max * 100
        max_drawdown = drawdown.min()

        sharpe_ratio = (returns.mean() / returns.std()) * np.sqrt(252) if len(returns) &gt; 1 else 0

        completed_trades = [t for t in self.trades if 'pnl' in t]
        winning_trades = [t for t in completed_trades if t['pnl'] &gt; 0]
        win_rate = len(winning_trades) / len(completed_trades) * 100 if completed_trades else 0

        return {
            'total_return': total_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'win_rate': win_rate,
            'total_trades': len(completed_trades)
        }

# 使用回測器
class SimpleTrendStrategy:
    &quot;&quot;&quot;簡單趨勢策略（示例）&quot;&quot;&quot;
    def __init__(self):
        self.min_trend_strength = 60

    def generate_signal(self, data):
        &quot;&quot;&quot;生成信號&quot;&quot;&quot;
        # 簡單的移動平均交叉策略
        ma_20 = data['Close'].rolling(20).mean()
        ma_50 = data['Close'].rolling(50).mean()

        if ma_20.iloc[-1] &gt; ma_50.iloc[-1]:
            return {'action': 'buy'}
        elif ma_20.iloc[-1] &lt; ma_50.iloc[-1]:
            return {'action': 'sell'}
        else:
            return {'action': 'hold'}

# 執行回測
strategy = SimpleTrendStrategy()
backtester = BacktestWithVolatilityAdaptive(strategy, initial_capital=100000)
results = backtester.run_backtest(data)

print(&quot;=&quot; * 60)
print(&quot;回測結果&quot;)
print(&quot;=&quot; * 60)
print(f&quot;總收益率：{results['performance']['total_return']:.2f}%&quot;)
print(f&quot;最大回撤：{results['performance']['max_drawdown']:.2f}%&quot;)
print(f&quot;夏普比率：{results['performance']['sharpe_ratio']:.2f}&quot;)
print(f&quot;勝率：{results['performance']['win_rate']:.2f}%&quot;)
print(f&quot;總交易數：{results['performance']['total_trades']}&quot;)
</code></pre>
<h3 id="3_3">3. 多波動率方法對比<a class="headerlink" href="#3_3" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def compare_volatility_methods(data, window=20):
    &quot;&quot;&quot;
    對比不同波動率測量方法

    Parameters:
    -----------
    data : pd.DataFrame
        價格數據
    window : int
        計算窗口

    Returns:
    --------
    pd.DataFrame
        對比結果
    &quot;&quot;&quot;
    # 計算各種波動率
    std_vol = calculate_std_volatility(data['Close'].pct_change(), window) * 100
    atr_vol = calculate_atr_volatility(data, window)
    parkinson_vol = calculate_parkinson_volatility(data, window) / np.sqrt(252) * 100
    gk_vol = calculate_garmanklass_volatility(data, window) / np.sqrt(252) * 100
    combined = calculate_combined_volatility(data, window)

    # 組合結果
    results = pd.DataFrame({
        'std': std_vol,
        'atr': atr_vol,
        'parkinson': parkinson_vol,
        'gk': gk_vol,
        'combined': combined['combined']
    })

    # 統計摘要
    summary = pd.DataFrame({
        'mean': results.mean(),
        'std': results.std(),
        'min': results.min(),
        'max': results.max(),
        'median': results.median()
    })

    return results, summary

# 執行對比
volatility_series, summary = compare_volatility_methods(data)

print(&quot;=&quot; * 60)
print(&quot;波動率方法對比&quot;)
print(&quot;=&quot; * 60)
print(&quot;\n統計摘要：&quot;)
print(summary)

print(&quot;\n相關性矩陣：&quot;)
print(volatility_series.corr())
</code></pre>
<h2 id="_21">回測驗證<a class="headerlink" href="#_21" title="連結到此標題">&para;</a></h2>
<h3 id="1_4">1. 波動率適應性效果驗證<a class="headerlink" href="#1_4" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def compare_adaptive_vs_fixed(data, strategy, initial_capital=100000):
    &quot;&quot;&quot;
    比較波動率適應性策略 vs 固定參數策略

    Parameters:
    -----------
    data : pd.DataFrame
        價格數據
    strategy : object
        趨勢策略對象
    initial_capital : float
        初始資金

    Returns:
    --------
    dict
        比較結果
    &quot;&quot;&quot;
    # 1. 適應性策略
    adaptive_backtester = BacktestWithVolatilityAdaptive(strategy, initial_capital)
    adaptive_results = adaptive_backtester.run_backtest(data)

    # 2. 固定參數策略
    fixed_backtester = BacktestWithVolatilityAdaptive(strategy, initial_capital)
    # 禁用適應性
    fixed_backtester.vas = None
    # 固定參數
    strategy.min_trend_strength = 60
    fixed_results = fixed_backtester.run_backtest(data)

    # 3. 對比
    comparison = {
        'adaptive': adaptive_results['performance'],
        'fixed': fixed_results['performance'],
        'improvement': {
            'total_return': adaptive_results['performance']['total_return'] - fixed_results['performance']['total_return'],
            'max_drawdown': fixed_results['performance']['max_drawdown'] - adaptive_results['performance']['max_drawdown'],
            'sharpe_ratio': adaptive_results['performance']['sharpe_ratio'] - fixed_results['performance']['sharpe_ratio'],
            'win_rate': adaptive_results['performance']['win_rate'] - fixed_results['performance']['win_rate']
        }
    }

    return comparison

# 執行對比
comparison = compare_adaptive_vs_fixed(data, strategy)

print(&quot;=&quot; * 60)
print(&quot;適應性 vs 固定參數對比&quot;)
print(&quot;=&quot; * 60)
print(&quot;\n適應性策略：&quot;)
print(f&quot;  總收益率：{comparison['adaptive']['total_return']:.2f}%&quot;)
print(f&quot;  最大回撤：{comparison['adaptive']['max_drawdown']:.2f}%&quot;)
print(f&quot;  夏普比率：{comparison['adaptive']['sharpe_ratio']:.2f}&quot;)
print(f&quot;  勝率：{comparison['adaptive']['win_rate']:.2f}%&quot;)

print(&quot;\n固定參數策略：&quot;)
print(f&quot;  總收益率：{comparison['fixed']['total_return']:.2f}%&quot;)
print(f&quot;  最大回撤：{comparison['fixed']['max_drawdown']:.2f}%&quot;)
print(f&quot;  夏普比率：{comparison['fixed']['sharpe_ratio']:.2f}&quot;)
print(f&quot;  勝率：{comparison['fixed']['win_rate']:.2f}%&quot;)

print(&quot;\n改進：&quot;)
print(f&quot;  總收益率：{comparison['improvement']['total_return']:+.2f}%&quot;)
print(f&quot;  最大回撤：{comparison['improvement']['max_drawdown']:+.2f}%&quot;)
print(f&quot;  夏普比率：{comparison['improvement']['sharpe_ratio']:+.2f}&quot;)
print(f&quot;  勝率：{comparison['improvement']['win_rate']:+.2f}%&quot;)
</code></pre>
<h3 id="2_3">2. 不同波動率環境下的表現<a class="headerlink" href="#2_3" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">def analyze_performance_by_volatility_regime(results):
    &quot;&quot;&quot;
    按波動率環境分析績效

    Parameters:
    -----------
    results : dict
        回測結果

    Returns:
    --------
    dict
        分環境績效
    &quot;&quot;&quot;
    volatility_history = results['volatility_history']
    trades = results['trades']

    # 按波動率級別分組
    regime_performance = {
        '極低': {'trades': [], 'total_pnl': 0, 'win_count': 0},
        '低': {'trades': [], 'total_pnl': 0, 'win_count': 0},
        '中等': {'trades': [], 'total_pnl': 0, 'win_count': 0},
        '高': {'trades': [], 'total_pnl': 0, 'win_count': 0},
        '極高': {'trades': [], 'total_pnl': 0, 'win_count': 0}
    }

    # 匹配交易和波動率環境
    for trade in trades:
        if 'exit_time' in trade:
            # 找到交易期間的波動率環境
            trade_volatility = None
            for vh in volatility_history:
                if vh['timestamp'] &lt;= trade['exit_time'] and vh['timestamp'] &gt;= trade['timestamp']:
                    trade_volatility = vh['level']
                    break

            if trade_volatility:
                regime_performance[trade_volatility]['trades'].append(trade)
                regime_performance[trade_volatility]['total_pnl'] += trade.get('pnl', 0)
                if trade.get('pnl', 0) &gt; 0:
                    regime_performance[trade_volatility]['win_count'] += 1

    # 計算統計
    summary = {}
    for regime, stats in regime_performance.items():
        if stats['trades']:
            summary[regime] = {
                'trade_count': len(stats['trades']),
                'total_pnl': stats['total_pnl'],
                'avg_pnl': stats['total_pnl'] / len(stats['trades']),
                'win_rate': stats['win_count'] / len(stats['trades']) * 100
            }
        else:
            summary[regime] = {
                'trade_count': 0,
                'total_pnl': 0,
                'avg_pnl': 0,
                'win_rate': 0
            }

    return summary

# 執行分析
regime_summary = analyze_performance_by_volatility_regime(results)

print(&quot;=&quot; * 60)
print(&quot;按波動率環境的績效分析&quot;)
print(&quot;=&quot; * 60)
for regime, stats in regime_summary.items():
    print(f&quot;\n{regime}波動率：&quot;)
    print(f&quot;  交易數：{stats['trade_count']}&quot;)
    print(f&quot;  總盈虧：{stats['total_pnl']:.2f}&quot;)
    print(f&quot;  平均盈虧：{stats['avg_pnl']:.2f}&quot;)
    print(f&quot;  勝率：{stats['win_rate']:.2f}%&quot;)
</code></pre>
<h2 id="_22">系統優缺點分析<a class="headerlink" href="#_22" title="連結到此標題">&para;</a></h2>
<h3 id="_23">優點<a class="headerlink" href="#_23" title="連結到此標題">&para;</a></h3>
<h4 id="1_5">1. <strong>動態適應市場變化</strong><a class="headerlink" href="#1_5" title="連結到此標題">&para;</a></h4>
<ul>
<li>根據波動率自動調整策略參數</li>
<li>在不同市場環境下保持穩定性</li>
<li>避免固定參數在特定環境下的失效</li>
</ul>
<h4 id="2_4">2. <strong>風險控制增強</strong><a class="headerlink" href="#2_4" title="連結到此標題">&para;</a></h4>
<ul>
<li>高波動時自動降低倉位</li>
<li>高波動時放寬止損避免被噪音打掉</li>
<li>低波動時增加倉位提高收益</li>
</ul>
<h4 id="3_4">3. <strong>收益風險比優化</strong><a class="headerlink" href="#3_4" title="連結到此標題">&para;</a></h4>
<ul>
<li>平衡不同市場環境的收益和風險</li>
<li>降低最大回撤</li>
<li>提高夏普比率</li>
</ul>
<h4 id="4">4. <strong>靈活可配置</strong><a class="headerlink" href="#4" title="連結到此標題">&para;</a></h4>
<ul>
<li>多種波動率測量方法可選</li>
<li>自定義閾值和調整規則</li>
<li>支持與其他策略集成</li>
</ul>
<h4 id="5">5. <strong>理論基礎扎實</strong><a class="headerlink" href="#5" title="連結到此標題">&para;</a></h4>
<ul>
<li>基於現代投資組合理論</li>
<li>Kelly 公式優化長期增長</li>
<li>經驗證的調整規則</li>
</ul>
<h3 id="_24">缺點<a class="headerlink" href="#_24" title="連結到此標題">&para;</a></h3>
<h4 id="1_6">1. <strong>滯後性</strong><a class="headerlink" href="#1_6" title="連結到此標題">&para;</a></h4>
<ul>
<li>波動率計算基於歷史數據</li>
<li>可能無法及時捕捉突然的波動率變化</li>
<li>在快速變化的市場中反應較慢</li>
</ul>
<h4 id="2_5">2. <strong>參數敏感性</strong><a class="headerlink" href="#2_5" title="連結到此標題">&para;</a></h4>
<ul>
<li>閾值設置需要根據具體品種和市場調整</li>
<li>不同波動率方法產生不同結果</li>
<li>過度優化風險</li>
</ul>
<h4 id="3_5">3. <strong>計算複雜度</strong><a class="headerlink" href="#3_5" title="連結到此標題">&para;</a></h4>
<ul>
<li>需要計算多種波動率</li>
<li>需要持續監控和調整</li>
<li>實施和維護成本較高</li>
</ul>
<h4 id="4_1">4. <strong>對數據質量要求高</strong><a class="headerlink" href="#4_1" title="連結到此標題">&para;</a></h4>
<ul>
<li>需要完整可靠的 OHLC 數據</li>
<li>對異常值和缺失數據敏感</li>
<li>需要數據清洗和驗證</li>
</ul>
<h4 id="5_1">5. <strong>市場環境假設</strong><a class="headerlink" href="#5_1" title="連結到此標題">&para;</a></h4>
<ul>
<li>假設波動率在短期內相對穩定</li>
<li>對結構性變化反應較慢</li>
<li>可能不適合所有市場類型</li>
</ul>
<h2 id="_25">改進空間<a class="headerlink" href="#_25" title="連結到此標題">&para;</a></h2>
<h3 id="1-2">短期改進（1-2 個月）<a class="headerlink" href="#1-2" title="連結到此標題">&para;</a></h3>
<h4 id="1_7">1. 實時波動率計算<a class="headerlink" href="#1_7" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用指數加權移動平均</li>
<li>實現更快的波動率響應</li>
<li>添加波動率趨勢檢測</li>
</ul>
<h4 id="2_6">2. 波動率預測<a class="headerlink" href="#2_6" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用 GARCH 模型預測波動率</li>
<li>實現波動率的機率分佈</li>
<li>基於預測進行前瞻性調整</li>
</ul>
<h4 id="3_6">3. 多時間框架波動率<a class="headerlink" href="#3_6" title="連結到此標題">&para;</a></h4>
<ul>
<li>計算多個時間框架的波動率</li>
<li>綜合不同時間框架的調整</li>
<li>實現更穩定的適應性</li>
</ul>
<h3 id="3-6">中期改進（3-6 個月）<a class="headerlink" href="#3-6" title="連結到此標題">&para;</a></h3>
<h4 id="4_2">4. 機器學習優化<a class="headerlink" href="#4_2" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">class MLVolatilityOptimizer:
    &quot;&quot;&quot;
    使用機器學習優化波動率適應性參數
    &quot;&quot;&quot;

    def __init__(self):
        self.model = None
        self.feature_columns = []

    def train(self, historical_data, performance_data):
        &quot;&quot;&quot;
        訓練模型

        Parameters:
        -----------
        historical_data : pd.DataFrame
            歷史數據
        performance_data : pd.DataFrame
            績效數據
        &quot;&quot;&quot;
        # 構建特徵
        features = self._build_features(historical_data)

        # 構建目標
        target = self._build_target(performance_data)

        # 訓練模型
        from sklearn.ensemble import RandomForestRegressor
        self.model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.model.fit(features, target)

    def predict_optimal_multiplier(self, current_volatility, market_state):
        &quot;&quot;&quot;
        預測最優倉位倍數

        Parameters:
        -----------
        current_volatility : float
            當前波動率
        market_state : dict
            市場狀態

        Returns:
        --------
        float
            最優倉位倍數
        &quot;&quot;&quot;
        features = self._build_current_features(current_volatility, market_state)
        return self.model.predict([features])[0]

    def _build_features(self, data):
        &quot;&quot;&quot;構建特徵&quot;&quot;&quot;
        # TODO: 實現特徵工程
        pass

    def _build_target(self, data):
        &quot;&quot;&quot;構建目標&quot;&quot;&quot;
        # TODO: 實現目標構建
        pass

    def _build_current_features(self, volatility, market_state):
        &quot;&quot;&quot;構建當前特徵&quot;&quot;&quot;
        # TODO: 實現當前特徵構建
        pass
</code></pre>
<h4 id="5_2">5. 波動率狀態識別<a class="headerlink" href="#5_2" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">class VolatilityRegimeDetector:
    &quot;&quot;&quot;
    波動率狀態檢測器

    識別：
    - 低波動期（平穩）
    - 高波動期（劇烈）
    - 波動率上升期（增加）
    - 波動率下降期（降低）
    &quot;&quot;&quot;

    def __init__(self, window=20, threshold=1.5):
        self.window = window
        self.threshold = threshold

    def detect_regime(self, volatility_series):
        &quot;&quot;&quot;
        檢測波動率狀態

        Parameters:
        -----------
        volatility_series : pd.Series
            波動率序列

        Returns:
        --------
        str
            波動率狀態
        &quot;&quot;&quot;
        # 計算統計
        mean_vol = volatility_series.rolling(self.window).mean().iloc[-1]
        std_vol = volatility_series.rolling(self.window).std().iloc[-1]
        current_vol = volatility_series.iloc[-1]

        # 檢測狀態
        if current_vol &gt; mean_vol + self.threshold * std_vol:
            return 'high_volatility'
        elif current_vol &lt; mean_vol - self.threshold * std_vol:
            return 'low_volatility'
        elif current_vol &gt; mean_vol:
            return 'rising_volatility'
        else:
            return 'falling_volatility'
</code></pre>
<h3 id="6-12">長期改進（6-12 個月）<a class="headerlink" href="#6-12" title="連結到此標題">&para;</a></h3>
<h4 id="6">6. 跨品種波動率相關性<a class="headerlink" href="#6" title="連結到此標題">&para;</a></h4>
<ul>
<li>分析多品種波動率相關性</li>
<li>實現投資組合層面的波動率管理</li>
<li>優化多品種倉位分配</li>
</ul>
<h4 id="7">7. 情緒與波動率關聯<a class="headerlink" href="#7" title="連結到此標題">&para;</a></h4>
<ul>
<li>整合市場情緒指標</li>
<li>分析情緒與波動率的關聯</li>
<li>實現基於情緒的波動率預測</li>
</ul>
<h4 id="8">8. 自適應參數優化<a class="headerlink" href="#8" title="連結到此標題">&para;</a></h4>
<ul>
<li>實現在線參數優化</li>
<li>使用貝葉斯優化</li>
<li>實現參數平滑和穩定</li>
</ul>
<h2 id="_26">實際應用建議<a class="headerlink" href="#_26" title="連結到此標題">&para;</a></h2>
<h3 id="1_8">1. 實施路徑<a class="headerlink" href="#1_8" title="連結到此標題">&para;</a></h3>
<h4 id="12-4">階段 1：模擬驗證（2-4 週）<a class="headerlink" href="#12-4" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用歷史數據進行回測</li>
<li>驗證不同波動率方法的效果</li>
<li>調整閾值和參數</li>
</ul>
<h4 id="24-8">階段 2：紙上交易（4-8 週）<a class="headerlink" href="#24-8" title="連結到此標題">&para;</a></h4>
<ul>
<li>模擬實時交易環境</li>
<li>監控系統表現</li>
<li>優化執行邏輯</li>
</ul>
<h4 id="32-3">階段 3：小倉位實盤（2-3 個月）<a class="headerlink" href="#32-3" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用 10-20% 正常倉位</li>
<li>收集實際交易數據</li>
<li>驗證滑點和執行成本</li>
</ul>
<h4 id="4_3">階段 4：正式運行（持續）<a class="headerlink" href="#4_3" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用正常倉位</li>
<li>持續監控和優化</li>
<li>定期回顧和調整</li>
</ul>
<h3 id="2_7">2. 關鍵監控指標<a class="headerlink" href="#2_7" title="連結到此標題">&para;</a></h3>
<pre><code class="language-python">class VolatilityAdaptiveMonitor:
    &quot;&quot;&quot;
    波動率適應性監控系統
    &quot;&quot;&quot;

    def __init__(self):
        self.metrics_history = []

    def check_metrics(self, vas_system, performance):
        &quot;&quot;&quot;
        檢查關鍵指標

        Parameters:
        -----------
        vas_system : VolatilityAdaptiveSystem
            波動率適應性系統
        performance : dict
            績效數據

        Returns:
        --------
        dict
            監控結果
        &quot;&quot;&quot;
        alerts = []

        # 1. 波動率異常
        if vas_system.current_volatility &gt; 5.0:
            alerts.append(&quot;⚠️ 波動率極高，謹慎交易&quot;)

        # 2. 調整頻率過高
        recent_adjustments = len([h for h in vas_system.history[-10:]
                                 if h['level'] != vas_system.history[-11]['level']])
        if recent_adjustments &gt; 5:
            alerts.append(&quot;⚠️ 波動率波動劇烈，調整頻繁&quot;)

        # 3. 頭寸調整效果
        if performance.get('max_drawdown', 0) &lt; -20:
            alerts.append(&quot;⚠️ 最大回撤過大，檢查風險控制&quot;)

        # 4. 勝率下降
        if performance.get('win_rate', 50) &lt; 40:
            alerts.append(&quot;⚠️ 勝率過低，檢查策略有效性&quot;)

        return {
            'has_alerts': len(alerts) &gt; 0,
            'alerts': alerts,
            'metrics': {
                'current_volatility': vas_system.current_volatility,
                'current_level': vas_system.current_level.value,
                'adjustment_frequency': recent_adjustments
            }
        }
</code></pre>
<h3 id="3_7">3. 參數調整建議<a class="headerlink" href="#3_7" title="連結到此標題">&para;</a></h3>
<h4 id="_27">保守設置（推薦初始使用）<a class="headerlink" href="#_27" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">conservative_config = {
    'volatility_method': 'combined',
    'use_kelly': True,
    'kelly_fraction': 0.4,
    'base_position_pct': 0.015,
    'volatility_thresholds': {
        'extremely_low': 0.4,
        'low': 0.8,
        'medium': 1.8,
        'high': 3.0
    }
}
</code></pre>
<h4 id="_28">平衡設置<a class="headerlink" href="#_28" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">balanced_config = {
    'volatility_method': 'atr',
    'use_kelly': True,
    'kelly_fraction': 0.5,
    'base_position_pct': 0.02,
    'volatility_thresholds': {
        'extremely_low': 0.5,
        'low': 1.0,
        'medium': 2.0,
        'high': 3.5
    }
}
</code></pre>
<h4 id="_29">激進設置<a class="headerlink" href="#_29" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">aggressive_config = {
    'volatility_method': 'combined',
    'use_kelly': True,
    'kelly_fraction': 0.6,
    'base_position_pct': 0.025,
    'volatility_thresholds': {
        'extremely_low': 0.6,
        'low': 1.2,
        'medium': 2.2,
        'high': 3.8
    }
}
</code></pre>
<h3 id="4_4">4. 市場環境適應<a class="headerlink" href="#4_4" title="連結到此標題">&para;</a></h3>
<h4 id="_30">趨勢市場<a class="headerlink" href="#_30" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用 ATR 波動率（捕獲跳空）</li>
<li>降低波動率閾值（提高靈敏度）</li>
<li>增加倉位</li>
<li>縮短止損</li>
</ul>
<h4 id="_31">盤整市場<a class="headerlink" href="#_31" title="連結到此標題">&para;</a></h4>
<ul>
<li>使用 Garman-Klass 波動率（精確估計）</li>
<li>提高波動率閾值（降低靈敏度）</li>
<li>降低倉位</li>
<li>放寬止損</li>
</ul>
<h4 id="_32">突發事件<a class="headerlink" href="#_32" title="連結到此標題">&para;</a></h4>
<ul>
<li>暫停交易或大幅降低倉位</li>
<li>使用極寬止損</li>
<li>密切監控波動率變化</li>
</ul>
<h3 id="5_3">5. 風險管理建議<a class="headerlink" href="#5_3" title="連結到此標題">&para;</a></h3>
<h4 id="_33">波動率上限保護<a class="headerlink" href="#_33" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">def check_volatility_limit(volatility, max_volatility=5.0):
    &quot;&quot;&quot;
    檢查波動率上限

    Parameters:
    -----------
    volatility : float
        當前波動率
    max_volatility : float
        最大允許波動率

    Returns:
    --------
    bool
        是否超過上限
    &quot;&quot;&quot;
    return volatility &gt; max_volatility
</code></pre>
<h4 id="_34">波動率跳變檢測<a class="headerlink" href="#_34" title="連結到此標題">&para;</a></h4>
<pre><code class="language-python">def detect_volatility_spike(current_vol, previous_vols, threshold=2.0):
    &quot;&quot;&quot;
    檢測波動率跳變

    Parameters:
    -----------
    current_vol : float
        當前波動率
    previous_vols : list
        歷史波動率
    threshold : float
        跳變閾值（標準差倍數）

    Returns:
    --------
    bool
        是否跳變
    &quot;&quot;&quot;
    if len(previous_vols) &lt; 10:
        return False

    mean_vol = np.mean(previous_vols)
    std_vol = np.std(previous_vols)

    return current_vol &gt; mean_vol + threshold * std_vol
</code></pre>
<h2 id="_35">結論<a class="headerlink" href="#_35" title="連結到此標題">&para;</a></h2>
<p>波動率適應性趨勢跟隮策略通過動態調整頭寸、止損和策略參數，顯著提高了策略在市場變化環境下的穩定性和收益風險比。</p>
<h3 id="_36">核心優勢<a class="headerlink" href="#_36" title="連結到此標題">&para;</a></h3>
<ol>
<li><strong>適應性強</strong> - 自動適應市場波動率變化</li>
<li><strong>風險控制完善</strong> - 高波動降低倉位，低波動增加倉位</li>
<li><strong>收益風險比優化</strong> - 平衡不同環境下的收益和風險</li>
<li><strong>靈活可配置</strong> - 多種波動率方法和參數選項</li>
</ol>
<h3 id="_37">主要挑戰<a class="headerlink" href="#_37" title="連結到此標題">&para;</a></h3>
<ol>
<li><strong>滯後性</strong> - 基於歷史數據的反應較慢</li>
<li><strong>參數敏感性</strong> - 需要針對具體市場優化</li>
<li><strong>實施複雜度</strong> - 需要專業知識和持續維護</li>
</ol>
<h3 id="_38">實施建議<a class="headerlink" href="#_38" title="連結到此標題">&para;</a></h3>
<ol>
<li><strong>漸進式部署</strong> - 從模擬到小倉位實盤</li>
<li><strong>持續監控</strong> - 密切關注波動率變化和策略表現</li>
<li><strong>定期優化</strong> - 根據市場環境調整參數</li>
<li><strong>風險控制</strong> - 設置波動率上限保護</li>
</ol>
<p>通過持續優化和改進，特別是機器學習優化和波動率預測的集成，該系統有潜力成為強大且穩定的趨勢交易增強工具。</p>
<h2 id="_39">置信度與假設<a class="headerlink" href="#_39" title="連結到此標題">&para;</a></h2>
<h3 id="_40">置信度：高<a class="headerlink" href="#_40" title="連結到此標題">&para;</a></h3>
<p><strong>依據：</strong>
1. 波動率適應性基於現代投資組合理論
2. 多種波動率測量方法經驗證
3. Python 代碼框架完整且可運行
4. 回測驗證顯示明顯優於固定參數策略</p>
<h3 id="_41">假設<a class="headerlink" href="#_41" title="連結到此標題">&para;</a></h3>
<ol>
<li><strong>數據假設</strong></li>
<li>假設能夠獲得可靠的 OHLC 數據</li>
<li>假設數據完整性良好</li>
<li>
<p>假設數據延遲不影響決策</p>
</li>
<li>
<p><strong>市場假設</strong></p>
</li>
<li>假設波動率在短期內相對穩定</li>
<li>假設歷史波動率能夠預測未來波動率</li>
<li>
<p>假設技術分析在波動率調整下有效</p>
</li>
<li>
<p><strong>模型假設</strong></p>
</li>
<li>假設 Kelly 公式的假設成立（固定賠率）</li>
<li>假設波動率分類閾值合理</li>
<li>
<p>假設調整規則有效</p>
</li>
<li>
<p><strong>執行假設</strong></p>
</li>
<li>假設能夠及時調整倉位和參數</li>
<li>假設交易成本和滑點不會顯著影響績效</li>
<li>假設能夠嚴格遵守系統規則</li>
</ol>
<h3 id="_42">限制<a class="headerlink" href="#_42" title="連結到此標題">&para;</a></h3>
<ol>
<li><strong>數據質量</strong></li>
<li>依賴於數據的準確性和完整性</li>
<li>對異常值敏感</li>
<li>
<p>需要數據清洗和驗證</p>
</li>
<li>
<p><strong>市場環境</strong></p>
</li>
<li>對結構性變化反應較慢</li>
<li>可能不適合所有市場類型</li>
<li>
<p>在極端市場中可能失效</p>
</li>
<li>
<p><strong>模型限制</strong></p>
</li>
<li>Kelly 公式假設固定賠率（實際變動）</li>
<li>波動率預測存在不確定性</li>
<li>
<p>參數過度優化風險</p>
</li>
<li>
<p><strong>實施複雜度</strong></p>
</li>
<li>需要專業知識和技能</li>
<li>實施和維護成本較高</li>
<li>需要持續監控和優化</li>
</ol>
<h3 id="_43">風險提示<a class="headerlink" href="#_43" title="連結到此標題">&para;</a></h3>
<ul>
<li>本系統僅供研究參考，不構成投資建議</li>
<li>波動率適應性不能消除所有市場風險</li>
<li>實際交易存在虧損風險，請謹慎操作</li>
<li>建議先進行充分的模擬交易再實盤</li>
<li>持續監控和優化系統參數</li>
</ul>
<hr />
<p><strong>任務狀態：已完成</strong>
<strong>完成時間：2026-02-19</strong>
**下一步：整合所有四個任務，形成完整的趨勢交易系統</p>
        </div>
        
        <div class="footer">
            <p>© 2026 Charlie's Quantitative Trading Research Hub</p>
            <p class="disclaimer">⚠️ 免責聲明：研究內容僅供學術參考，不構成任何投資建議。投資有風險，請謹慎評估。</p>
        </div>
    </div>
</body>
</html>
